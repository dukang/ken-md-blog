---
title: '(翻译系列) - Realtime Rendering 4th - 7. Shadows'
excerpt: '生命中的一切多样性、一切魅力和美好，都是来自于光和影。'
coverImage: '/assets/blog/Realtime%20Rendering%204th%20-%207%20Shadows%20a353501cbe254ee6b1b448ef54eb0020/Untitled.png'
date: '2022-07-24'
type: '实时渲染4TH'
author:
  name: Ken Du
  picture: '/assets/blog/authors/ken.png'
ogImage:
  url: '/assets/blog/Realtime%20Rendering%204th%20-%207%20Shadows%20a353501cbe254ee6b1b448ef54eb0020/Untitled.png'
---

# Realtime Rendering 4th - 7. Shadows

"All the variety, all the charm, all the beauty of life is made up of light and shadow."—Tolstoy

生命中的一切多样性、一切魅力和美好，都是来自于光和影。

图7.1展示了本章所使用的术语。其中occluders遮挡器将阴影投射到reveivers接收器上。Punctual light精准光源，即没有区域的光源，只产生fully shadowed region完全阴影区域，即hard硬阴影。如果使用area或者volume light，则会产生soft软阴影。每个阴影都可以有一个完全阴影区域（umbra本影），和一个部分阴影区域（penumbra半影）。软阴影的阴影边缘是模糊的。但是，需要注意的是，仅适用低通滤波器模糊硬阴影的边缘通常无法正确渲染它们。如图7.2所示，正确的软阴影的做法是，当遮挡器越接近接收器的时候，阴影越尖锐。软阴影的本影区域不等同于由punctual light生成的硬阴影。其实软阴影的本影区域随着光源的增大而减小，如果光源足够大，接收器距离遮挡器足够远，它甚至可能没有本影。大家更喜欢软阴影，因为其半影边缘更容易让观众知道，它确实是个阴影。而硬阴影通常看起来不太真实，优势会被误解为是实际物件的几何特征，比如曲面上的折痕。但是，硬阴影的渲染速度比软阴影快。

阴影：

light source: 光源

occluder: 遮挡物

receiver: 接受面

shadow: 阴影

umbra: 本影（全阴影）

penumbra: 半影 — 一般面积光才会产生半影（软阴影）

Punctual Light Source: 精确光源

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%207%20Shadows%20a353501cbe254ee6b1b448ef54eb0020/Untitled.png)

一般来说有阴影比完全没有显得真实，哪怕只放一个blur的圆片在地面代替阴影。

### Planar Shadows（平面阴影）:

当物体产生的阴影打到平面产生的阴影

1. Projection Shadows

投影矩阵推倒过程省略（有空可以回来看下）

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%207%20Shadows%20a353501cbe254ee6b1b448ef54eb0020/Untitled%201.png)

渲染阴影，渲染的物体应用这个投影矩阵到接收平面(相乘)，是一片黑色没有光的区域（应用颜色微黑色）。

第一个问题要避免阴影渲染到receiver的下面，一个方法就是先渲染 ground，然后关闭深度写入，再渲染阴影

第二个问题是如果平面面积有限，且投影阴影可能会落在投影平面外面，这时一般用stencil buffer。先把接收平面画进屏幕和stencil buffer里面，然后关闭深度写入，然后只在stencil buffer 有值的地方绘制阴影。

另外一种算法是把阴影渲染进纹理中，然后应用在投影平面上。这种纹理是一种lightmap。这样可以同时支持本影（umbra）和半影（penumbra）。但是这种方法的缺陷是纹理可能被拉伸，可能1个纹理像素覆盖了多个屏幕像素，这样丢失了精度，破坏了光照。如果阴影的条件没有随着每帧改变，那么light-map可以被复用，提高计算效率。

根据投影矩阵，如果光源在投影接收平面与物体之间，会产生antishadow，这是错误的，应该不会产生阴影。一般可以用显式裁剪来避免这样的情况。

1. **软阴影(soft shadows)**

投影阴影也是可以产生软阴影的，这里阐述一下Heckbert and Herf的算法。

方式一：一般软阴影的产生需要光源有面积。你可以理解为把punctual lights放到光源的表面上组成的面光源。对于每个punctual light source渲染结果会被累加到一个buffer里面（一个纹理），然后计算buffer的平均值就是软阴影。Heckbert and Herf用基于锥体的方式产生阴影，方式是把光源当作观察者，然后接收平面是锥体的远平面，这个锥体宽度是包括了所有的遮蔽体的。虽然效果真实，但是这种方式计算量特别大。

<aside>
💡 所谓的punctual lights指具有位置(location)的光，区别于平行光。但是punctual lights没有形状、尺寸，和真实世界的光源不同。术语"punctual"和守时没有关系，而是来自拉语*punctus*，意思是"point"，指从单个位置发光的光源。接下来会介绍两种punctual lights：点光源(point light)和聚光灯(spotlight)。其中，点光源，"point light"，光线均匀地照射在各个方向。

</aside>

方式二：一种比较有效率的方式是通过blur（卷积算法）硬阴影，但是物体接近地面部分的影子也变得很模糊，比较不真实，并不能准确反映出物体的轮廓。

### Shadow on Curved Surfaces （曲面上的阴影）

在曲面上产生阴影，最简单的方法就是生成一张阴影贴图。

从光源的角度看物体，看到的物体就是在光照下的，看不到的就是在阴影中的. 然后receiver 对这张贴图进行采样，receiver的顶点uv可以在application阶段计算 . 这与上一节说的 ground shadow texture有点不同, 上一节说 物体 被投射到一个特殊的平面，这儿，阴影贴图是从光源的视角产生的。

纹理投影的方式有两个重大的缺陷：

1. 程序必须要识别那些是遮挡物，哪些是接收物，而且接收物必须要离光源更远不然就会出现“反阴影”的问题。
2. 遮挡物不能对自身产生阴影。

好处是可以提前制作投影纹理，减少性能消耗。

### Shadow Volumes（阴影体积）

体积阴影1991被提出，只需要用stencil buffer，基本上没有采样的问题，但是只能生成硬阴影，目前使用阴影体积的方式已经很少了，就不详细讲了。

- 由于其开销难以估计，阴影体积如今已很少使用，但相关研究仍在进行

### Shadow Maps

1978年，Williams提出Z-buffer的方式来生成阴影。相对于光源的z-buffer，当光源能够“看见”的标识为光亮，剩下的表示为阴影，Lighting, texturing, and writing values into the color buffer 都可以被关闭。

这个z-buffer就是所谓的shadow map，然后根据z-buffer来进行渲染，如果在视点看到某个像素，这个像素如果比z-buffer的标识要更远，那这个物体的像素就在阴影中，以此类推。这个技术是通过纹理映射实现的，比如：

 

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%207%20Shadows%20a353501cbe254ee6b1b448ef54eb0020/Untitled%202.png)

> **阴影映射是一种流行的算法，因为它是相对可预测的. 构建阴影贴图的成本与渲染物体的数量大致呈线性关系，而访问时间是恒定的. 只要物体在光照下不移动， shadow map 就是可以被重复使用的。**
> 

场景中并不是所有的物体都被渲染到shadow map 中，只有可以投射阴影的物体才被渲染.  比如 如果物体超出一定的范围 就不投射阴影了，一些很小的物体也不投射阴影.如下图：

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%207%20Shadows%20a353501cbe254ee6b1b448ef54eb0020/Untitled%203.png)

如上图中.凡是超出 view frustum 的物体也不投射阴影，来动态的调节light volume 的大小. 只渲染看得见的物体的阴影，不仅仅能节省时间，还能提高阴影贴图的分辨率，从而提高阴影的质量.

光源的阴影frustum和视角的frustum可以进行culling，增加效率。

shaow mapping缺点：

1. 阴影的质量取决于shadow map的像素分辨率以及z-buffer的精度，因为shadow map 是在深度值比较之后 再进行采样的，该算法容易出现混叠问题，特别是接近物体之间的接触点. 一个普遍问题是 self-shadow aliasing,也叫 “surface acne” or “shadow acne,”

2. 常见的问题是自阴影混叠（self-shadow aliasing），此问题有两个来源。 一种就是处理器精度的数值极限。（**一个三角形本应该给其他物体投射阴影的，但是它自己也被它产生的阴影投射了，也就是它采样了它自己投射的阴影，这个问题的根源有两个：一是处理器的精度所致，它的深度值和shadow map中的深度值一比较，确实它就应该在阴影中** ） 另一个来源是几何，这是因为使用了像素点样本的值来表示区域（三角形）的深度。 也就是说，为光生成的样本几乎永远不会与屏幕样本位于相同的位置（例如，像素通常是在其中心进行采样）。 将灯光的存储深度值与查看的曲面的深度进行比较时，灯光的值可能会比曲面的深度略低，从而导致自阴影。

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%207%20Shadows%20a353501cbe254ee6b1b448ef54eb0020/Untitled%204.png)

一个通用的方式是使用阴影偏差（Shadow bias），用一个系数对该物体的深度值进行一定的增加或减少，来避免自阴影混叠。

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%207%20Shadows%20a353501cbe254ee6b1b448ef54eb0020/Untitled%205.png)

这些  bias 是一个常量值，但是当receiver 不是面向光源的时候，就会失败，一个更有效的方法是，偏移量根据receiver  和光源的角度成正比变化，表面越偏离光线，偏差就越大. 这种类型的偏差被称为坡度尺度偏差( slope scale bias). 这两种 biases 都可以使用同一种命令来执行，比如 OpenGL的glPolygonOffset. 注意如果receiver 直面光源，则它是不会产生bias 的，因为角度为0,这时就需要constant bias 和它一起使用 Slope scale bias 同时也是有限制的，因为因为当表面在光线下接近边缘时，切线值可能会非常高。

Holbert [759, 760] 提出了 normal offset bias, 它首先是朝着 表面的法线方向，偏移receiver 世界空间下的位置,和 法线与光源角度的sin 值成正比，比如：

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%207%20Shadows%20a353501cbe254ee6b1b448ef54eb0020/Untitled%206.png)

这改变的不仅仅是深度值，还有在shadow map 中进行采样点的uv 坐标，当光源与法线的角度增加时，bias 也会增加，从而避免self-shadow

如果 bias 太大 ，会造成light leaks 也叫 Peter Panning 的问题，阴影和caster  分离了。

另一种解决 self-shadowing 问题的方法是： shadow map 中只渲染 物体的背面，也叫 second-depth shadow mapping [1845], 当bias 不好用时用这个，但是当一个物体很薄，正反面都可见时，就会出问题，因为它背面和正面的位置是一样的，这时 添加一个 bias 可以解决这个问题，但该方案更容易受到光泄漏的影响，因为在接触点接收器和闭塞器的背面之间没有分离。

注意   shadow mapping, 渲染的物体必须是不透明的，比如固体，或者必须正面和反面都被渲染到shadow map中，否则物体可能不会完全投射阴影. Woo [1900] 提出一个方法，用正面和反面之间的平面，这种方法是，把固体渲染到shadow map 中，并追踪表面上距离光源最近的两个点 . 这个过程可以通过 深度剥离或其他与透明相关的技术执行，两个物体之间的平均深度形成一个中间层，其深度被用作阴影贴图，有时称为双阴影贴图dual shadow map [1865]. 如果一个物体足够厚，self-shadowing 和 light-leak 就会很小.它的缺点就是用了两张shadow map。

随着视角的移动， light’s view volume 的大小也会随着投射物体的改变而改变，这样反过来也影响了阴影的改变，这是因为light’s shadow map 是通过从光源投射的不同方向采样的，对于平行光，解决方法是 force each succeeding shadow map generated to maintain the same relative texel beam locations in world space [927, 1227, 1792, 1810]. 也就是说，你可以把阴影纹理想象成一个二维的网格，每个网格单元代表贴图上的一个像素采样点. 也就是随着视角的移动，生成的阴影始终是阴影贴图上的这些点。

### Resolution Enhancement（分辨率增强）

理想情况下，我们希望一个阴影贴图纹素覆盖大约一个图像像素。 如果我们的光源位于与眼睛相同的位置，则阴影贴图与屏幕空间像素完美地一对一映射（并且没有可见的阴影，因为光线恰好照亮了眼睛所看到的）。 光线的方向一改变，阴影纹理对应图像像素比率就会改变，这可能会导致伪影（artifacts）。这种情况叫作透视走样（perspective aliasing），如下图（降采样和超采样）

> 透视走样是指阴影越靠近摄像机，其边缘的锯齿化（走样）现象就越严重，这是因为阴影贴图的分辨率是固定的，而透视投影的效果是近大远小，同样大小的一个阴影所对应的阴影贴图中纹素的大小也是固定的。而在渲染时，当阴影越靠近摄像机，就越容易出现多个片元从阴影贴图中的同一个纹素进行采样的情况，这几个片元得到的同一个阴影值，因而产生锯齿边。
> 

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%207%20Shadows%20a353501cbe254ee6b1b448ef54eb0020/Untitled%207.png)

当阴影靠近光源的时候，且面向视点，这是会存在一个阴影纹素对应多个图像像素的情况，这种情况称为**投影走样（projective aliasing）。**

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%207%20Shadows%20a353501cbe254ee6b1b448ef54eb0020/Untitled%208.png)

**这种可以通过提高阴影贴图的分辨率来降低这种变现，但是需要额外的内存**

目前大部分优化的方式是修改光源的变化矩阵，使得像素分配均匀。如下图变化矩阵后使得纹素在更接近眼睛的部分覆盖更多细节。

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%207%20Shadows%20a353501cbe254ee6b1b448ef54eb0020/Untitled%209.png)

右图就是阴影在靠近眼睛的地方，texel的密度更大。

在将光线的视角映射到眼睛的视角时，有22°的自由度 [896]. 通过这种方法解决问题有几种不同的算法，它们试图更好地匹配光线的采样率和眼睛的采样率，包括 perspective shadow maps (PSM) [1691], trapezoidal shadow maps (TSM) [1132], and light space perspective shadow maps (LiSPSM) [1893, 1895]. See Figure 7.15 and Figure 7.26 on page 254 for examples. 这类技术叫做 perspective warping methods.

这种matrix-warping algorithms的优点就是只需要更改light’s matrices不需要其它操作，这些方法在光源方向和物体垂直的时候很好as the perspective transform can then be shifted to put more samples closer to the eye。

但是这种方法当光源在摄像机前面，并且照向摄像机的时候就会失效， 更靠近眼睛的地方需要更多的阴影贴图样本，但是线性扭曲只会使情况更糟[1555]. 还有阴影贴图的质量的突变，也是它不受欢迎的地方

2006年，有人提出分割视锥体，根据视角方向平行的方向进行分拆。对于每个分割的视锥体，光源可以生成相应的锥体覆盖这部分视锥体然后生成阴影纹理。这种方式称为-cascade shadow maps（集联阴影映射CSM）。

生成多张shadow maps. 原理就是: 创建多张shadow map (可能是不同的分辨率)，覆盖场景中不同的区域. 比如四张.通过这种方式，视角靠近物体的地方，阴影贴图的分辨率高，距离视角越远的物体，阴影的分辨率越低。

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%207%20Shadows%20a353501cbe254ee6b1b448ef54eb0020/Untitled%2010.png)

随着深度的增加，每一个 volume 都有两到三张阴影贴图. **通过使用图集不同的阴影贴图可以被当做一张贴图**
. 效果如下图

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%207%20Shadows%20a353501cbe254ee6b1b448ef54eb0020/Untitled%2011.png)

左，场景的可视范围广，导致单个2048×2048分辨率的阴影贴图具有透视锯齿。 右，沿视轴放置的四个1024×1024阴影贴图可显着提高质量。 插入的红色框中显示了围栏前角的缩放。

这种方法合理，而且实用性好，所以被广泛使用。

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%207%20Shadows%20a353501cbe254ee6b1b448ef54eb0020/Untitled%2012.png)

上图显示了从摄像机视角，不同的区域覆盖的阴影贴图不一样，越靠近摄像机的视锥体，有更多的采样点， 确定如何在不同的距离划分不同的视锥体的方法叫做 z-partitioning，一种方法是 logarithmic partitioning [1062]。每一个部分视锥的“长度”（near到far）均为r，即以对数比例划分，f和n是far 和 near平面的长度, c是maps的数量。

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%207%20Shadows%20a353501cbe254ee6b1b448ef54eb0020/Untitled%2013.png)

> n 是近平面 f 是元平面， c 是生成shadow map 的数量，r 是最终的比例，比如：n= 1 米， f= 1000 米, 我们有三张shadow map, 则 r = 3 1000/1 = 10. 最近的视锥体则是 1 - 10, 下一个视锥体的范围是10-100, 最后一个是 100 到1000 ，但是如果n很小的话， 只有 0.1 米，则r= 21.54, 比如, 0.1 to 2.154 to 46.42 to 1000. 这意味着每一个shadow map 都会覆盖很大的一片区域，降低了阴影的分辨率，在实践中，这样的划分给近平面附近的区域提供了相当大的分辨率，如果该区域没有对象，这就浪费了. 一种避免这种不匹配的方法是将分割距离设置为对数和等距分布的加权混合(1962,1963)，但如果我们能够确定场景的紧密视图边界，那将会更好。
> 

> 问题在于设置n的大小，如果太远了，n 太大了，物体就会被裁切掉，一种方法是sample distribution shadow maps (SDSM), 它使用前一帧的z-depth值通过两种方法中的一种来确定一个更好的分区。
> 

> 第一种方法是通过z深度寻找最小值和最大值，并使用这些值来设置近平面和远平面. 这是在GPU上使用reduce操作来执行的，在这个过程中，一系列越来越小的缓冲区被compute or other shader分析，output buffer区作为输入反馈，直到一个1 × 1缓冲区被留下. 通常情况下，这些值被挤出一点来调整场景中物体的移动速度。除非采取纠正措施，否则从屏幕边缘进入的物体可能仍然会对画面造成问题，但会在接下来的画面中迅速纠正。这种方法还是挺快的。
> 

> 当阴影在级联阴影贴图中跳跃时，会产生闪烁，在世界空间中保持稳定采样点的方法有多种，每种方法都有各自的优点. 一个方法是. 让切分的 view volumes 稍微重叠一下，这样重叠的区域就会在两个shadow map中混合，另一种方法是使用抖动法在该区域内取单个采样点1381].
> 

> 因为这种方法流行，所以更多的讨论是怎么让它更高效的执行，如果一个视锥体的阴影没有改变，则这个级联的阴影贴图就不用重新计算. 对于每一个光源，会预结算一系列的shadow casters  ，从而查找哪些物体是在光源下的，哪些可以接收阴影.由于很难判断一个阴影是否正确，可以采取一些适用于级联算法和其他算法的捷径 ，一种方法是，一种技术是使用低层次的细节模型作为代理来实际投射阴影 [652, 1812]. 另一种方法是移除微小的遮挡物[1381, 1811]. 离摄像机很远的shadow map  应很少被更新，因为它们不重要，但是对于大的移动的物体，需要特别关心， DOOM (2016) 游戏维持了一个很大的阴影贴图的图集，只有当物体移动时，会重新生成这些阴影贴图，越远的级联贴图可以设置为完全忽略动态对象，因为这样的阴影可能对场景贡献很小.  在某些环境中，可以使用高分辨率的静态阴影贴图来代替这些更远的级联，这可以显著减少工作负载[415, 1590]. Cascaded shadow mapping 可以和烘焙光照贴图一起使用。
> 

> 创建多张阴影贴图，意味着需要需要执行多次pass ,需要优化的算法都是为了在一个pass中渲染多张shadow map. 几何着色器可以用来复制对象数据并将其发送到多个视图 [41]，也就是MRT. Instanced geometry shaders allow an object to be output into up to 32 depth textures [1456].
> 

> 利用遮挡剔除，剔除哪些被遮挡的物体，由于辐照度随距离的平方而下降，一种常见的技术是在一定的阈值距离后剔除光源.
> 

---

### Percentage-Closer Filtering - 百分比靠近过滤法（PCF）

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%207%20Shadows%20a353501cbe254ee6b1b448ef54eb0020/Untitled%2014.png)

> 如下图，点采样会根据uv值，找到最近的整数坐标，用该位置的texel作为采样结果。而线性采样则对附近的四个texel进行一定的插值运算。而在Shadow map采样，如果利用点采样或者线性采样得到一个深度值，然后在于即将渲染的pixel的深度进行比较的话，最终结果是二值化的。就是说即将渲染的pixel只有两种情况，在阴影内部或者外部。这种二值化的特性直接导致shadow map是没有半影现象了，加上shadow map的分辨率有限，当其被放大的时候，经常会有精度不足的情况出现，所以会导致出现严重的锯齿。这也是shadow map算法最致命的一个问题了。
> 

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%207%20Shadows%20a353501cbe254ee6b1b448ef54eb0020/Untitled%2015.png)

如上图，为了在阴影边缘产生柔和的阴影，将接收表面的深度分别与四个最接近的texel上的深度进行比较，然后针对每个阴影贴图样本确定该点在光还是阴影中。 然后对这些结果（即阴影的0和光的1）进行双线性插值，以计算实际上对表面位置有多少贡献的光。这与纹理放大时的插值模糊有异曲同工之妙。这种多重阴影纹理采样然后混合结果插值的方式称为—percentage-closer filtering（PCF）。“percentage-closer filtering” 的最终目的是找到在光照下可见的百分比，也就是一个像素多少是暴露在光下面的。

> 问题1: 这样有个问题，这个半影的范围在PCF算法里面是固定的，也就是不管物体离光源或者接收面的距离，都会产生半影，这跟实际情况是不一样的（一个现实观察是，当投影物与阴影之间的距离越远，则阴影越软（如下图：笔尖阴影由于与笔尖的距离较近，因此阴影边缘较为锐利；而远处笔身阴影则因与笔身距离较远，阴影边缘较为发散且模糊））
> 

一旦采样的区域的宽度确定了，剩下来的就是避免锯齿， 这些变量包括采样区域的宽度、使用多少个样本、采样模式以及如何对结果加权. 在api能力较差的情况下，采样过程可以通过一种类似于双线性插值的特殊纹理采样模式来加速，该模式访问四个相邻的节点. 不是混合结果，而是将四个样本中的每一个都与给定的值进行比较，并返回通过测试的比率 .  然而，在常规网格模式中执行最近邻采样可能会产生明显的伪影. Using a joint bilateral filter that blurs the result but respects object edges can improve quality while avoiding shadows leaking onto other surfaces [1343]. See Section 12.1.1 for more on this filtering technique.

DirectX 10  为PCF引入了单指令双线性滤波支持，给出了更平滑的结果 [53, 412, 1709, 1790].  这提供了相当大的视觉改善最近邻采样，但来自常规采样的伪迹仍然是一个问题. 一个最小化 grid patterns 的方法是使用预计算的 Poisson distribution pattern，如下图：

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%207%20Shadows%20a353501cbe254ee6b1b448ef54eb0020/Untitled%2016.png)

这种分布将样本分散开来，使它们既不彼此靠近，也不呈规则模式.  众所周知，对每个像素使用相同的采样位置，无论分布如何，都会导致所有的软影很相似，我们可以通过随机渲染采样点来避免.

Self-shadowing 和 light leaks问题，在使用pcf 时会变得更糟. Slope scale bias 仅仅基于它与光线的角度增加它与光源的距离， 假设一个样本在阴影贴图上不超过一个texel. 通过从一个表面的单一位置在一个更大的区域取样，这个区域可能会真的变成硬阴影。

为了避免self-shadow. Burley [212]描述了一个bias cone, 每一个采样点移动的距离和它与原采样点距离成正比. 如下图：

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%207%20Shadows%20a353501cbe254ee6b1b448ef54eb0020/Untitled%2017.png)

### Percentage-Closer Soft Shadows

PCF 的一个问题就是采样区域的宽度是个常量，这些阴影表现得软阴影都是一样的，这在一些场景中是对的，但是当occluder 与 receiver 相接处的地方，就会差错。例如：

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%207%20Shadows%20a353501cbe254ee6b1b448ef54eb0020/Untitled%2018.png)

PCSS 就是为了解决问题1:

In 2005 Fernando [212, 467, 1252] 提出了一个具有影响力的方法叫 percentage- closer soft shadows (PCSS). 他尝试对 表面位置 在shadow map 中的邻近区域查找所有可能的 occluders. 这些点到 occluders 的平均距离，来决定了采样的宽度：

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%207%20Shadows%20a353501cbe254ee6b1b448ef54eb0020/Untitled%2019.png)

**dr 是receiver 到 light 的距离， do 是occluder 到灯光的平均距离，也就是说, 软影的宽度，随着occluder 离光源的位置越近而变得越大。**

如果没有遮挡物，则该表面是在光照下的，如果完全被遮挡，就不会进行下面的平均值处理了，如果都不是，则就会进行软影计算，为了节省性能，. Other- wise, then the area of interest is sampled and the light’s approximate contribution is computed. 样本区域的宽度可以用来改变采样的数量。还有一些其它的技术：比如对远阴影降低采样频率。

这种方法的缺点就是采样点多，然后找出所有的occluder,使用rotated Poisson disk pattern可以隐藏降采样产生的效果，. Jimenez [832] 法线这种方法不稳定，然后他发现 使用介于抖动和随机之间的函数可以在帧与帧之间得到更好的结果

Sikachev et al. [1641] 发现了一种使该方法更有效的方法,叫 contact hardening shadows (CHS). 这个也解决了另一个偏移的问题，如上图，.首先通过生成阴影贴图的mipmap，然后选择最接近用户定义的世界空间内核大小的mip级别，可以最小化这个问题.一个  8 × 8 区域被采样，来查找该blocker 的平均深度，只需要调用 16 次GatherRed() ，一旦确定了半影的位置，一个高分辨率的mipmap 对那些sharp area的阴影使用，然后对软影使用低分辨率的mipmap的 shadow map。

一个已被证明的有助于加速计算的方法就是，记录两个mipmap 的最大z-depth,和一个最小的z-depth,它可以用来快速的决定该pixel 是在光照下，还是在阴影中，比如如果一个texel 的z-depth 还要大，说明该像素在阴影中，其它的采样点就不需要了。

它的缺点就是当do 非常大时，可能会出现问题。

### Filtered Shadow Maps

一种允许过滤 shadow map 的算法 叫 variance shadow map (VSM) [368]. 这种算法 在一张map 中存储深度值，另一个map 中存储 深度值的平方，在生成map 时，可以使用 MSAA or 其他的抗锯齿算法，这些map 可以被blurred, mipmapped, 然后放进一个 summed area tables 里[988],  将这些地图视为可过滤纹理的能力是一个巨大的优势，因为当从这些地图中检索数据时，可以使用整个阵列的采样和过滤技术。

我们将在这里深入描述VSM，以了解这个过程是如何工作的;同样，这类算法中的所有方法都使用相同类型的测试.

首先， VSM 的第一张map 被采样一次，然后返回距离光源最近的occluders的平均深度值，. 用 M1, 是否大于receiver  点t在shadow map 上的深度值 如果是，则该点在光照下，否则，进行下面的公式:

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%207%20Shadows%20a353501cbe254ee6b1b448ef54eb0020/Untitled%2020.png)

pmax 是在光照下的最大采样点，σ2 是方差variance, t 是receiver 的深度值， M1 是shadow map 的平均深度值，然后在第二张map 采样得到的值用 M2表示，用来计算方差：

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%207%20Shadows%20a353501cbe254ee6b1b448ef54eb0020/Untitled%2021.png)

pmax是receiver 可接受光照的最大值，实际光照的值，不会大于该值，这个方程试图用概率论来估计，在表面位置上有多少遮挡器的分布超出了表面与光线的距离. Donnelly和Lauritzen表明，对于固定深度的平面遮挡器和平面接收器，p = pmax，因此公式7.7可以用来作为许多真实阴影情况的很好的近似。

一个区域的方差，在阴影的边缘会增加，深度上的差异越大，差异也就越大.  (t − M1)2 是能见度百分比的重要决定因素. 如果这个值略高于零, 这意味着occluder的平均深度比receiver更接近光，然后pmax接近1(全亮). 这将发生在半影完全亮的边缘. M1变得更接近光，所以 (t − M1)2 变得更大，pmax下降.

总的来说，由于GPU的优化纹理能力被有效地使用，VSM在处理时间的数量上提供了显著的质量提高. PCF 需要更多的采样点，所以需要更多的时间 ， VSM可以只使用一个单一的、高质量的采样点来确定整个区域的效果，并产生一个平滑的半影. 这种能力意味着在算法的限制下，阴影可以在不增加额外成本的情况下任意变成软阴影。

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%207%20Shadows%20a353501cbe254ee6b1b448ef54eb0020/Untitled%2022.png)

VSM很适合从地形产生阴影，因为这种阴影很少涉及多个遮挡器[1227]。 VSM is good for producing shadows from terrain, since such shadows rarely involve multiple occluders [1227].

Called an exponential shadow map (ESM) or exponential variance shadow map (EVSM), 这个方法把深度值得指数值保存到两个buffer中，指数函数更接近于shadow map 里执行的 step function ，所以它减少了 光的泄露。它是经常用的。.

### Volumetric Shadow Techniques

光线穿过透明物体，会让光衰减或者改变光的颜色，比如：在某些情况下会生成第二种类型的shadow map ，如果是渲染透明物体，shadow map 存储了最近点的深度值和颜色值，或者是alpha值，如果receiver 没有被不透明的物体遮挡，则透明的shadow map 的depth 就会和表面作比较，如果遮挡了，就和不透明的shadow map 深度值作比较。

Self-shadowing 对于云或者头发来说很重要，当物体很小或者透明的时候，单个shadow map 不能适应这种情况.

reference:

[https://blog.csdn.net/weixin_44422550/article/details/104900124](https://blog.csdn.net/weixin_44422550/article/details/104900124)

[https://blog.csdn.net/cgy56191948/article/details/105716007](https://blog.csdn.net/cgy56191948/article/details/105716007)

[https://blog.csdn.net/qq_37672438/article/details/121595807](https://blog.csdn.net/qq_37672438/article/details/121595807)