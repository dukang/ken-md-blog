---
title: '(翻译系列) - Realtime Rendering 4th - 5. Shading Basics'
excerpt: '每一幅画都是一个优美的故事，梵高。'
coverImage: '/assets/blog/Realtime Rendering 4th - 5 Shading Basics 44845826d0c44eeaae3c78d28f65d8a7/Untitled.png'
date: '2022-07-24'
type: '实时渲染4TH'
author:
  name: Ken Du
  picture: '/assets/blog/authors/ken.png'
ogImage:
  url: '/assets/blog/rr4-3/6.png'
---

# Realtime Rendering 4th - 5. Shading Basics

“A good picture is equivalent to a good deed.”
—Vincent Van Gogh

每一幅画都是一个优美的故事，梵高。

### 5.1 着色模型

第一步是根据着色模型决定渲染物体的外观，来解析决定物体的颜色变化的因素，比如说物体朝向，视角的方向和光线。

Gooch shading的中心思想在于对比表面法线和光源位置。如果法线指向光源，则使用较暖色调为表面着色，如果法线远离光源，则使用较冷色调。当中间角度的时候，再基于用户提供的表面颜色，在冷暖之间做插值。在这个粒子中，我们增加了一个风格化的高光，是的曲面会有光泽外表。图5.2展示了着色模型。

着色模型通常包含一些参数用来控制物体外表的变化。如下图拥有一个变量，surface color(表面颜色)，来决定显示的颜色信息。

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%205%20Shading%20Basics%2044845826d0c44eeaae3c78d28f65d8a7/Untitled.png)

和大多数着色模型一样，此示例受到曲面方向normal、视图view、光照方向的影响。为了进行着色，这些方向通常表示为标准化（单位长度）向量，如图5.3所示。

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%205%20Shading%20Basics%2044845826d0c44eeaae3c78d28f65d8a7/Untitled%201.png)

这样我们就定义了这个光照模型的所有变量，下面为光照模型的公式：

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%205%20Shading%20Basics%2044845826d0c44eeaae3c78d28f65d8a7/Untitled%202.png)

这个公式所需要用到的所有中间变量

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%205%20Shading%20Basics%2044845826d0c44eeaae3c78d28f65d8a7/Untitled%203.png)

该定义中的很多数学表达式也经常出现在其他着色模型中。clamp操作经常在着色中用于将结果限定在0到正无穷大，或者0到1之间。在这里，用于计算高光混合因子s的公式中可以看到-+符号，这个我们在1.2节介绍过，就是用于表示clapmp(0,1)。点积运算符出现了三次，是一种常见的用于计算两个单位向量夹角余弦的方式，它的结果很精确。比如在着色模型中计算normal和light夹角关系的时候经常会被使用。

还有一个经常被使用的着色运算是使用0-1之间的标量值在两个颜色之间进行线性插值。此操作的公式为tCa+(1-t)Cb，当t的值在0-1之间移动时，在Ca和Cb之间进行插值。该公式在着色模型中出现了两次，第一次是Cwarm和Ccool之间，第二次是上次插值的结果和Chightlight之间。线性插值经常在shading中被使用，所以它有一个内置函数lerp或mix。

公式r = 2(nl)n - l是用于计算光l相对于n的反射矢量。虽然不像前面两个那么常见，但是很多着色语言也会有对应的内置函数reflect。

通过将这些操作以各种不同的方式和参数结合，就得到了各种着色模型用于各种风格（风格化或者写实风）的渲染表面。

### 5.2 光源

光源的影响在上面的例子中非常简单； 它为着色提供了一种主要的方向。当然，光线在真实世界里面是非常复杂的。可能会存在多个光线资源，并且它们又各自的大小，形状，颜色和强度。间接光照甚至拥有更多更复杂的变量。

相对比，风格化着色模型会根据应用的需求以及观察风格，以各种不同的方式使用光照。一些高度风格化的着色模型没有一点光照的成分，或者仅仅只是用来提供简单的方向性（像前面提到的Gooch shading）。

光照中下一个比较复杂的地方是需要根据与光照的关系，选择不同的着色模型。这种表面在光下会有一个外观，在不受光的情况下会有另外一个外观。这也就意味着需要区分这两种情况的一些标准：与光源的距离、阴影（第七章）、表面是否背离光源（n和l的角度超过90度），或者是这些因素的合集。

或者换一种方式来思考，我们不再考虑光照是否存在的二元性，而是考虑光照强度的连续渐变。这样的话，就可以从光源完全不存在到光源完全存在进行插值，强度的范围可以用0-1表示。或者还有另外一种方式，将各种影响着色的因素相加，常见的方式是：将着色模型分解成亮部和不亮部，灯光强度Klight线性的影响光照部分：

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%205%20Shading%20Basics%2044845826d0c44eeaae3c78d28f65d8a7/Untitled%204.png)

这也很容易扩展为一种RGB的光线颜色Clight

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%205%20Shading%20Basics%2044845826d0c44eeaae3c78d28f65d8a7/Untitled%205.png)

对于多光源的情况

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%205%20Shading%20Basics%2044845826d0c44eeaae3c78d28f65d8a7/Untitled%206.png)

不受光的部分funlit(n,v)相当于二元性着色模型中处理表面不受光影响的部分。根据游戏的风格，可以使用多种风格。比如，funlit()=(0,0,0)也就代表着不受光的表面，表现为黑色。其他的，比如也可以类似Gooch model中那样，使用冷色来表示表面背离光照。通常，着色模型中的这一部分表示某种形式的照明，这些照明不是直接来自显示放置的光源，而是来自比如天光或者周围对象反射的光。这些形式的照明将在第10、11章中讨论。

我们前面提到，如果光照方向l与法线n的角度超过90度，则光照不会影响到表面，也就是说光照来自表面下方。这可以被看作是光照对表面的影响的一种特殊情况。尽管这种情况是基于物理的，但其实对很多非物理的风格化着色模型也很有用。

光对表面的影响可以被看作是一组光线，照射到表面的光线密度与用于表面着色的光照强度相对应。如图5.4所示，该图显示了照明表面的横截面。沿着横截面照射到表面上的光线的间距与L和N之间夹角的余弦值成反比。因此，照射到表面上的光线的总比密度与L和N之间夹角的余弦值成正比，余弦值为L和N两个单位长度向量的点积。在这里我，我们也就可以看到为什么光向量L与实际光的方向相反，因为不然的话，必须先对它求反

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%205%20Shading%20Basics%2044845826d0c44eeaae3c78d28f65d8a7/Untitled%207.png)

更准确的说，光线密度（或者说光线对着色的贡献程度），当点积为正数时，与点积成正比。当点积为负数时，也就是说，光线是从表面后面发出来的，这样没有效果。所以，当用点积计算光照着色的时候，首先先clamp到0,。在这里可以使用1.2节的符号x+，将负值限制到0，也就是如下公式

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%205%20Shading%20Basics%2044845826d0c44eeaae3c78d28f65d8a7/Untitled%208.png)

最简单的光照模型是将其看成一个常数颜色

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%205%20Shading%20Basics%2044845826d0c44eeaae3c78d28f65d8a7/Untitled%209.png)

也就得到如下着色模型

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%205%20Shading%20Basics%2044845826d0c44eeaae3c78d28f65d8a7/Untitled%2010.png)

这个模型被称为lambertian光照模型，是由Johann Heinrich Lambert（参考文献[967]）于1760年发布。该模型适用于理想情况下的漫反射表面，也就是毫无光泽的表面。这里我们先简单的介绍一下它，然后再第9章会更详细的介绍。Lambert模型本身可以用于简单的着色，同时也是很多着色模型中的关键组成部分。

从上述公式中，我们可以看到，光源是通过两个参数影响光照模型：光照的方向l，以及光照的颜色Clight。所以，可以根据光源的这两个参数，将光源分成各种不同类型。

5.2.1 方向光

方向光是光源中最简单的类型。l和clight在场景中都是恒定的，clight可以通过阴影减弱。方向光没有位置。当然，实际光源肯定是有位置的，然而由于方向光是抽象的，当与灯光距离比较大的时候，比如，一个很远的灯光照亮桌面上的一个小物件的时候，可以看成是方向光。另外一个例子是使用太阳的场景，基本都会认为太阳是方向光，除非讨论的场景是整个太阳系。

方向光的概念可以稍微扩展一下，以允许在光方向l保持不变的情况下，改变clight的值。这通常是想借助光效，实现场景中的一些特殊效果。比如，将一个区域定义成两个嵌套的区域，在这两个区域过度的时候进行平滑插值得到clight。

5.2.2 精准光源

精准光源是指有位置的光源。与现实世界的光源不同，这种光源也没有尺寸和形状。Punctual来自拉丁语中的Punctus，是点的意思。用来表示单一的，有位置的所有类型的光源。点光源代表着向各个方向均匀发光的光源。聚光灯和点光源是两种不同类型的精准光源。光的方向l取决于当前正在绘制的表面点P0，以及精准光源的位置Plighting

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%205%20Shading%20Basics%2044845826d0c44eeaae3c78d28f65d8a7/Untitled%2011.png)

这个公式也是向量归一化的一个示例：向量除以向量的长度，以得到一个相同方向的单位长度向量。这也是一个常见的操作，在大多数着色语言中有对应的内置函数。但是，有时也需要此操作的中间结果，这样就需要把这个公式拆成好几步，如下所示：

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%205%20Shading%20Basics%2044845826d0c44eeaae3c78d28f65d8a7/Untitled%2012.png)

我们知道点积就是两个向量的长度相乘，然后乘以它们夹角的余弦值。而0°的余弦值为1，所以向量和自身的点积等于向量长度的平方。所以，为了计算出向量的长度，我们通常对其自身进行点积运算，然后再进行开方。

通常我们需要中间变量r，也就是光源和当前着色点之间的距离。因为我们有时候会用r距离作为衰减因子，这个将在后面进行讨论。

**Point/Omni Lights**

在所有方向均匀发光的精确光源被称为点光源或者Omni光源。对点光源来说，Clight的值随着距离r的变化而变化，唯一的变化源是上面提到的距离衰减。图5.5显示了这种变暗现象发生的原因，原理和图5.4的余弦系数差不多。但是与5.4的余弦系数不同，针对平行光，垂直于平行光方向移动物件，物件上的点与光源的夹角始终不变，但是点光源不一样。来自点光源的光线之间的间距与从表面到光源的距离成比例关系，所以该点与光源的夹角也在变化。所以随着间距的增加，变化是分为两个维度的，所以光线密度与距离的平方成反比。这样，我们就可以通过r0点光源Clight0计算出最终的Clight

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%205%20Shading%20Basics%2044845826d0c44eeaae3c78d28f65d8a7/Untitled%2013.png)

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%205%20Shading%20Basics%2044845826d0c44eeaae3c78d28f65d8a7/Untitled%2014.png)

如上图所示，光线之间的距离随着距离r的变大而变大。所以光线密度/强度与r的平方成反比。

上面这个公式被称为inverse-square light attenuation。尽管技术上没毛病，但是在实际着色中可能会出问题。

首先，第一个问题出现在短距离的情况下。当r趋近于0的时候，clight将无限大。当r等于0的时候，就会遇到除0的问题。通常的解决方案是加一个很小的值做除0保护。

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%205%20Shading%20Basics%2044845826d0c44eeaae3c78d28f65d8a7/Untitled%2015.png)

这个很小的值的具体取值取决于应用程序，比如Unreal取极小值为1厘米。

在CryEngine（参考文献[1591]）和Frostbit（参考文献[960]）中，将r clamp到Rmin中：

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%205%20Shading%20Basics%2044845826d0c44eeaae3c78d28f65d8a7/Untitled%2016.png)

在这里，Rmin有一个物理意义：物理光源的半径，当r小于rmin的时候，物体表面在光源中，这不可能(Patrick：这个比较有道理，R0=Rmin，然后无限靠近光源的时候，Clight=Clight0)

相反，平方反比衰减的第二个问题在相对较大的距离上。问题并非在视觉上，而是性能上。因为尽管光强度随着距离的增加而减小，但它永远都不会到达0。而为了有效的渲染，我们希望灯光在某个有限距离达到0强度（详见第20章）。有许多不同的方法可以对平方反比方程进行修改来实现这一点。理想情况下，修改应当尽可能少。而为了避免在光的有效边界处出现尖锐的切口，在相同的距离处，修正函数的导数和值最好同时达到0。一种解决方案是用具有所需特性的开窗函数乘以平方反比方程。UE（参考文献[861]）Frostbite（参考文献[960]）都使用了这样的功能（参考文献[860]）

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%205%20Shading%20Basics%2044845826d0c44eeaae3c78d28f65d8a7/Untitled%2017.png)

公式中的+2意思为，先将值clamp到0，然后再对其进行平方。图5.6中显示了平方反比曲线的例子，方程式5.14中窗函数的例子，以及它们相乘的结果

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%205%20Shading%20Basics%2044845826d0c44eeaae3c78d28f65d8a7/Untitled%2018.png)

上图中将公式中的Rmax设置为3。

需要根据应用程序的需要选择使用的方法。比如，当距离衰减函数以相对较低的空间频率（比如lightmap或顶点光源）采样时，在Rmax处导数等于0尤为重要。Cryengine不使用lightmap或顶点光照，因此它使用了更简单的调整，在0.8*Rmax到Rmax的范围内采用线性衰减。

在某些应用中，平方反比衰减并非最优选，而选择了其他的一些函数，所以我们将5.11-5.14概括成下述公式：

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%205%20Shading%20Basics%2044845826d0c44eeaae3c78d28f65d8a7/Untitled%2019.png)

其中Fdist（r）是距离函数。这种函数被称为距离衰减函数。在某些情况下，是由于性能原因而不使用平方反比衰减函数。比如Just Cause 2这个游戏就需要计算量比较少的光源。从而引入了一些计算量比较少，而同样足够平滑以避免顶点光照瑕疵的函数（参考文献[1379]）

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%205%20Shading%20Basics%2044845826d0c44eeaae3c78d28f65d8a7/Untitled%2020.png)

还有一些别的情况，是为了实现一些比较有意思的效果，才选择不同的衰减函数。比如UE中就有两种衰减函数，用于真实和风格化的游戏：一个是平方反比模型，正如5.12公式中一样，另外一个是指数衰减函数用于创建各种各样的衰减曲线（参考文献[1802]）。Tomb Raider古墓丽影（2013）的开发者就使用了spline-editing工具（参考文献[953]），从而对衰减曲线进行更强的控制。

以上聊到的光源都是抽象的。真实世界中的光源都是有尺寸和形状的，且针对物体表面上的照射是从多个方向的。在渲染行业，这种光源被称为面光源，在实时渲染领域，其使用频率也越来越高。面光源的使用主要集中在两个方面：模拟部分遮挡面光源导致的阴影边缘软化技术（详见7.1.2节），模拟面光源对表面着色效果的影响技术（详见10.1节）。其中第二个方面针对光滑的镜面表面影响最为明显，在这些表面上，光线的形状和大小都可以通过其反射清晰的辨别出来。方向光和精准光源虽然不像过去那样无处不在了，但是不太可能被废弃。目前，已经开发出了比较简单的公式模拟面光源的近似值，这种公式耗能低，所以可以得到更广泛的应用。GPU性能的提高也使得可以使用越来越复杂的技术。

### **5.3 实现着色模型**

然后这些着色和光照方程需要在代码中实现。被接种，我们讲讨论一些设计和编写此类实现的关键注意事项。然后会介绍一个简单的实现示例。

5.3.1 运算频率

当设计一个着色模型的时候，需要先根据运算频率将一些运算进行区分。首先，针对在整个DC中，都保持不变的运算，可以将其由应用程序在CPU端执行，尽管GPU也比较擅长运算。然后将CPU运算的结果，通过图形API中的uniform传入。

即使这个类型的数据，也可能分为很多不同的可能性。最简单的例子是着色方程中的常量表达式，然而其实这些可以通过硬件配置或者安装选项等表示。这些计算应当在shader编译的时候就完成，这种情况下甚至不需要通过uniform传入。或者，也可以在离线预计算的时候、安装的时候或者应用程序加载的时候运算。

另一种情况是，着色运算的结果在应用程序运行期间会发生变化，但速度太慢，不需要每帧都更新。例如，光照取决于虚拟游戏世界中的时间。如果光照计算的成本很高，可以尝试通过多帧进行分摊

其它的还有，逐帧更新的运算，比如V和P矩阵。逐物件更新的运算，比如依赖位置运算的光照参数。逐DC更新的运算，比如材质球属性。按照频率对uniform进行分组可以有效的提高性能，通过最小化变量更新的方式降低GPU开销。

当某个被需要的运算在一个DC中会发生变化的时候，则不能通过uniform将该运算的结果传入shader，而是需要用到第3章中提到的着色器来计算，如果需要，还可以通过varying来进行不同着色器之间的数据传输。理论上，着色计算可以在任何可编程阶段进行，而每个阶段对应不同的运算频率：

- Vertex Shader：逐pre-tesselation顶点运算。
- Hull Shader：逐surface patch运算。
- Domain Shader：逐post-tesselation顶点运算。
- Geometry Shader：逐图元运算。
- Pixel Shader：逐像素运算。

实际上，大多数着色计算是逐像素进行的。虽然这些通常在pixel shader中实现，但computer shader的使用也越来越多，在第20章会给出一些例子。其他阶段主要用于几何运算，比如transform和变形。为了理解为什么着色计算要逐像素计算，下面我们对比一下逐顶点和逐像素计算的结果。在旧的文本中，也被称为Gouraud shading（参考文献[578]）和Phong shading（参考文献[1414]），这些术语现在已经不用了。这个比较中使用的着色模型类似公式5.1，但是经过修改，可以使用多个光源。等我们说完细节之后，会给出完整的模型。

下图5.9可以看出两种顶点密度的模型，**分别使用逐顶点着色和逐像素着色的区别**。对于龙的那个模型，顶点密度很高，两种着色的差别很小。而对于茶壶，使用顶点着色的话会出现明显的错误，比如高光部分。而对于两个三角形平面来说，顶点着色完全不正确。这些错误的原因是因为着色方程的某些部分，特别是高光部分，在网格表面呈非线性变化。这使得，如果使用顶点着色，以线性插值的方式得到结果的方式，结果是不对的。

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%205%20Shading%20Basics%2044845826d0c44eeaae3c78d28f65d8a7/Untitled%2021.png)

上图为逐顶点和逐像素，以5.19着色模型，针对三种不同顶点密度模型所得到的对比图。左侧为逐像素的结果，中间为逐顶点的结果，右侧为模型的wireframe，可以看到其顶点密度。（中国龙的模型来自Computer Graphics Archive（参考文献[1172]），而原始模型来自Stanford 3D Scanning Repository）

理论上，可以在PS中只计算高光部分，其他部分在VS中进行计算。这样的话效果没区别，性能上理论上还会有所节省。但实际上，这种混合方式往往并非最优解。着色模型中线性变换的部分，往往是计算量最小的部分，以这种方式拆分着色计算，往往会导致更多的开销，比如重复计算以及额外的varying变量，这些消耗甚至可能超过节省的部分。

如前所述，VS主要负责非着色部分，比如几何体transform和变形。将生成的几何曲面属性转换为适当的坐标系，由VS输出，在三角形中线性插值后，作为varying输入传给PS。这些属性通常包括位置、法线以及可选的切线（如果需要做法线映射）

需要注意的是，即使VS中对法线做了归一化处理，但是插值后的向量依然可能是非归一化的。如图5.10所示。所以在PS中还需要对法线进行重新归一化。而VS中的法线归一化依然不可缺少。因为如果顶点之间的法线长度变换很大，比如做顶点混合的时候，这个将会扭曲插值。这可以在图5.10的右侧看到。所以，需要在插值之前和之后，也就是在VS和PS中都进行归一化。

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%205%20Shading%20Basics%2044845826d0c44eeaae3c78d28f65d8a7/Untitled%2022.png)

在左侧，我们可以看到，单位法线在曲面上的线性插值会产生长度小于1的插值向量。在右侧，我们看到长度显著不同的法线的线性插值，会导致插值方向向两条法线中较长的方向倾斜。

与法线不同，指向特定位置的向量（比如view向量、精准光源的灯光向量）通常不进行插值。而在PS中通过插值得到的曲面位置来计算这些向量。这些计算中，只有必须在ps中进行的归一化之外，只需要一个向量减法即可，这个计算量很小。如果出于什么原因，比如将这个运算放到VS中，则不要对其进行归一化，否则将会出现不正确的结果，如图5.11所示。

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%205%20Shading%20Basics%2044845826d0c44eeaae3c78d28f65d8a7/Untitled%2023.png)

上图为对两个灯光向量进行插值。左图为，在插值之前先归一化，会导致插值后方向错误。右图可以看到，直接对非归一化的向量进行插值，结果是对的。(Patrick：这个挺有意思的)

前面我们提到VS将几何体转换到适当的坐标系中。摄像机和光源的位置由应用程序转换到相同的坐标系中。这样的话，将最大程度降低PS的计算量。但是哪个坐标系是合适的？可能是世界坐标系，也可能是相机的视图坐标系，甚至可能是模型的局部坐标系。具体使用哪个坐标系，通常是基于系统性考虑（比如性能、灵活性和简单性）。比如，如果渲染场景中包含大量灯光，则可以选择世界空间以避免过多的变化灯光位置。或者，可以使用相机坐标系，来更好的优化依赖view向量的PS操作，这样的话精度可能还会得到提高（详见16.6节）

尽管大多数着色器都是按照上述描述的原则，但是凡事均有意外。比如，一些应用程序使用逐图元的渲染以实现风格化的效果。这种风格被称为flat shading。图5.12显示了两个例子。