---
title: '(翻译系列) - Realtime Rendering 4th - 6. Texturing(纹理)'
excerpt: '各种各样的纹理都是为了增加真实性体验和合理性。'
coverImage: '/assets/blog/Realtime Rendering 4th - 6 Texturing(纹理) cb0c3597962c4c4d85f92e77335ec33c/Untitled 1.png'
date: '2022-07-24'
type: '实时渲染4TH'
author:
  name: Ken Du
  picture: '/assets/blog/authors/ken.png'
ogImage:
  url: '/assets/blog/Realtime Rendering 4th - 6 Texturing(纹理) cb0c3597962c4c4d85f92e77335ec33c/Untitled 1.png'
---

# Realtime Rendering 4th - 6. Texturing(纹理)

“All it takes is for the rendered image to look right.”
—Jim Blinn

各种各样的纹理都是为了增加真实性体验和合理性。

在本章中，将详细介绍纹理技术。首先，提出了处理纹理的整个框架。然后，我们会重点关注用于物体表面的纹理，这也是实时渲染中纹理的最常见的一种方式。之后还会简单的聊一下程序纹理，并会聊一些通过纹理影响物体表面的方法。

## 6.1 The Texturing Pipeline(纹理的流水线)

纹理是一种高效参数化表面材质和颜色的技术。区分于屏幕像素，图像纹理的像素我们一般称为纹素。纹理化可以理解为生成纹理的流水线，解下来会详细介绍纹理生成的每个流程。

空间的位置是纹理化进程的起点。这个位置可以是在世界空间中，但是大部分情况是以模型微参照准则，纹理会根据模型移动而移动。这个空间中的纹素点都会有一个应用方程，用来获取一系列纹素，称为纹理坐标体系。这个过程称为纹理映射。

在纹理坐标获取纹理值之前，我们还需要用一个通信方程把纹理坐标转化到纹理空间。这些纹理空间的地址用来获取纹理的值。如下图：

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%206%20Texturing(%E7%BA%B9%E7%90%86)%20cb0c3597962c4c4d85f92e77335ec33c/Untitled.png)

先找到物体的空间位置，然后通过projector function（投影方程）找到相应的纹理坐标参数（UV），然后通过corresponder function计算出纹理空间地址，获取纹理的值，然后通过value transform function获取转化后的纹理值。如下图所示：

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%206%20Texturing(%E7%BA%B9%E7%90%86)%20cb0c3597962c4c4d85f92e77335ec33c/Untitled%201.png)

### 6.1.1 The Projector Function（投影方程）

纹理进程的第一步是获取物体表面的位置，然后投影到纹理坐标空间，一般用二维空间u,v表示。通常美术会定义每个顶点的u,v坐标。投影方程通常转化三维的空间点到纹理坐标体系。

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%206%20Texturing(%E7%BA%B9%E7%90%86)%20cb0c3597962c4c4d85f92e77335ec33c/Untitled%202.png)

还有其他的投影方程，比如表面法向量用来选择6个平面映射的方向中的哪个作用于表面。立方体映射方程映射了立方体的不同的面等。投影方程的目的是生成纹理坐标。一般投影方程的调用不会在渲染进程内，一般由美术进行拆分模型然后应用投影方程。所以一般投影方程应用在建模的阶段，但是也有发生在顶点着色阶段用来进行提升精度和适应一些特效（动画等）。

通常有些扭曲的表面需要美术对于模型进行unwrapping使得曲面更接近平面化，用来映射纹理。

纹理坐标空间不一定是二维的平面，有时候可以是三维的向量(u,v,w)，其中w代表沿着某个方向的深度信息。也可能是四个坐标(s,t,r,q)，其中q代表齐次坐标。另外一个纹理坐标空间的重点类型是方向，每个在空间中的点可以被输入的方向获取。

由于不同的纹理应用在物体表面，有多套纹理坐标可能需要被定义使用。但是都是围绕一个目的：这些纹理坐标在表面被插值用来获取纹理的值。在被插值前，这些纹理坐标会被conresponder function转化。

### 6.1.2 The Corresponder Function

The Corresponder Function把**纹理坐标(u,v)**转化为**纹理空间(纹素坐标)**坐标。常见的方程有：

- wrap, repeat or tile — 代表图像在物体表面重复自己
- mirror — 代表图像在物体表面重复自己，每次重复都是通过镜像的方式
- clamp or clamp to edge — 超过[0,1]的范围的值会被clamp到这个范围，形成纹理边缘延伸的效果。跟边框无关，这样可以避免双线性差值的时候意外获取到对面边界的纹素
- border or clamp to border — 超过[0,1]边界的会绘制成边界颜色，这个颜色可自定义

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%206%20Texturing(%E7%BA%B9%E7%90%86)%20cb0c3597962c4c4d85f92e77335ec33c/Untitled%203.png)

### 6.1.3 Texture Values

The Corresponder Function之后可以生成**纹理世界的坐标**，可以用这些坐标来获取纹理的值。纹理世界坐标可以进入图像纹理，直接获取图像的纹素信息。对于程序纹理，可能需要通过计算方程来获取纹素信息。

## 6.2 Image Texturing（图像纹理）

在shader里面，我们通过texture2D（u，v）用纹理坐标的值获取纹理的值，这个方法里面进行了相应的corresponder function映射到[0.0, 1.0]的范围。然后GPU把这些值转为具体的**纹素坐标**。

其中，DirectX 左上是(0.0, 0.0),右下是(1.0, 1.0)，而openGL左下是(0, 0)，相对于DirectX是沿y轴翻转。

> 依靠纹理读取（dependent texture read）。有两种定义，第一种尤其适合移动设备，当通过texture2D或类似的函数来访问纹理，依靠纹理读取会发生在像素着色器计算纹理坐标时（取代了从顶点着色器中传过来的无修改纹理坐标），注意，这意味着对传入纹理坐标可做任何修改，甚至简答的交换u和v的值。在早期移动GPU上，如OpenGL ES3.0，就不支持依靠纹理读取，纹素数据可以预取到。另外一种定义对早期桌面GPU很重要，依靠纹理读取发生在当一个纹理坐标需要依靠先前的纹理坐标的时候。例如， 一个纹理可以改变着色法线，通过访问一个立方体贴图轮流改变纹理坐标。在纹理图像大小通常是个纹素，其中m和n都是非负整数，这些都是2的幂次方（power-of-two，POT）纹理，现代GPU可以处理非2幂次方（non-power-of-two，NPOT）的纹理了，允许生成的图像可以当做纹理。然而，一些老的移动GPU可能不支持NPOT纹理的mipmapping（多级渐远纹理）。图像加速器对纹理大小的上限不一样，DirectX 12允许的最大纹素是这种方式对性能有影响。
> 

### 6.2.1 Magnification

当纹理的**纹素**小于应用的**像素**的时候，图形系统通常会放大纹理(***纹理本身太小，纹理的分辨率不够，图像上的多个像素在渲染时取纹理映射上取到了同一个点，会有明显的方块状。我们将纹理上的每个像素称为-texel（纹理元素，纹素）***)。在图6.8中，将大小为48×48像素的纹理贴图到一个正方形上，并且正方形相对于纹理大小而言非常接近，因此基础图形系统必须放大该纹理。通常的放大过滤技术是nearest neighbor 和 bilinera interpolation。还有另外一种方式称为cubic convolution, 用4x4 或者 5x5的纹素数组的权重和做计算。尽管底层硬件设备目前不是特别支持cubic convolution， 它还是被用在shader program当中。

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%206%20Texturing(%E7%BA%B9%E7%90%86)%20cb0c3597962c4c4d85f92e77335ec33c/Untitled%204.png)

左边的使用nearest neighbor ，只采样邻近的单个texel值 作为 该pixel的值，产生了像素化的效果

中间的使用bilinear interpolation，通过采取邻近四个texel的值，然后进行水平垂直方向上的插值，获得最后的color，结果就是会模糊

在同一图的中间图像中，使用了双线性插值（有时称为线性插值（linear interpolation））。 对于每个像素，这种滤波都会找到四个相邻的纹理像素，并在二维上进行线性插值，以找到像素的混合值。 结果是模糊的，使用最近邻居方法产生的许多锯齿现象已消失。 作为实验，请在眯眼时尝试看左图像，因为它的效果与低通滤镜大致相同，并且可以使脸部露出更多。

最右边的使用bicubic filter ，同样也能移除像素画的效果，但是他要比 bilinear filters花费更高的性能。

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%206%20Texturing(%E7%BA%B9%E7%90%86)%20cb0c3597962c4c4d85f92e77335ec33c/Untitled%205.png)

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%206%20Texturing(%E7%BA%B9%E7%90%86)%20cb0c3597962c4c4d85f92e77335ec33c/Untitled%206.png)

比如我们获取到的pixel 坐标为(pu,pv) = (81.92,74.24)，也就是它在(81.42, 73.74)的坐标空间原点下，那么该texel的坐标为(81, 73) 到 (82, 74).而该点具体的颜色值，在(0.42,0.74)的位置，首先分为两步，我们要计算左下角和右上角的颜色值，然后进行插值。

凭直觉，越接近我们样本位置的纹理像素将对其最终值产生更大的影响。这确实是我们在等式中看到的。在（x + 1，y + 1）处的右上纹素具有u'v'的影响。请注意对称性：右上角的影响等于左下角和样本点形成的矩形的面积。回到我们的示例，这意味着从该纹理像素检索的值将乘以0.42×0.74，实际是0.3108。从该纹理像素顺时针方向，其他乘数分别为0.42×0.26、0.58×0.26和0.58×0.74，所有这四个权重的总和为1.0。（在双线性插值当中离的越近的颜色，对像素影响越大）

双线性差值有时候会有噪点，可以用bicubic filters进行过滤，但是性能消耗昂贵。Qu´ılez [1451]提出了一种简单的技术，即使用平滑曲线在一组2×2纹素之间进行插值。我们首先讲曲线，然后讲技术。 两条常用的曲线是平滑步幅。一种是smoothstep 和 quintic两种平滑过渡曲线进行过滤。一定程度上消除噪点。

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%206%20Texturing(%E7%BA%B9%E7%90%86)%20cb0c3597962c4c4d85f92e77335ec33c/Untitled%207.png)

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%206%20Texturing(%E7%BA%B9%E7%90%86)%20cb0c3597962c4c4d85f92e77335ec33c/Untitled%208.png)

### 6.2.2 Minification

缩小：将高分辨率的纹理贴到低分辨率的画布，即一个 pixel 覆盖了多个 texel

从采样理论来看：我们把放大看作是上采样，那么缩小就看作是下采样。

根据奈奎斯特定理：**当采样频率大于信号最大频率 2 倍的时候，就可以不失真采样。**

一张纹理的最大频率可以是如下情况：一黑一白两个像素紧挨着，不断重复，此时的周期为 2，频率为 1/2，那么采样频率必须至少为 1 才能做到不走样，即 pixel 的个数至少要多于 texel 个数。这与缩小的情况相违背，所以缩小有可能走样。

当对纹理进行缩小的时候，几个纹素可以覆盖一个像素的单元格。如图6.13所示。若要针对每个像素获取正确的颜色值，需要计算出每个纹素对像素的影响。然而，很难精确的确定该像素所有周边纹素对其的影响，而且在实时计算中也不可能完美的做到这一点。

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%206%20Texturing(%E7%BA%B9%E7%90%86)%20cb0c3597962c4c4d85f92e77335ec33c/Untitled%209.png)

经常可以使用的另一个滤波器是双线性插值，其工作原理与放大滤波器完全相同。 该过滤器仅比最邻近的方法略胜一筹。经常可以使用的另一个滤波器是双线性插值，其工作原理与放大滤波器完全相同。 该过滤器仅比最邻近的方法略胜一筹。它混合了四个纹素，而不是仅使用一个，但是当一个像素受到四个以上纹素的影响时，滤镜很快就会失效并产生锯齿。

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%206%20Texturing(%E7%BA%B9%E7%90%86)%20cb0c3597962c4c4d85f92e77335ec33c/Untitled%2010.png)

上图中顶部的图像使用点采样（nearest），中图使用mipmap，底图使用summed area tables面积总和表进行渲染。

更好的解决方案是可能的。 如第5.4.1节所述，可以通过采样和过滤技术解决混叠问题。纹理的信号频率取决于其纹理像素在屏幕上的间隔。由于Nyquist 限制，我们需要确保纹理的信号频率不大于采样频率的一半。例如，假设一张图像是由交替的黑白线组成的，相隔一个纹素。波长为两个纹理像素宽（从黑线到黑线），因此频率为1/2。为了在屏幕上正确显示此纹理，频率必须至少为2×1/2，即每个纹理像素至少一个像素。 因此，通常对于纹理，每个像素最多应有一个纹理像素以避免混叠。

为了实现此目标，必须增加**像素的采样频率**或降低**纹理频率**。前一章讨论的抗锯齿方法提供了提高像素采样率的方法。 但是，这些仅有限地增加了采样频率。 为了更充分地解决这个问题，已经开发了各种纹理缩小算法。

所有纹理抗锯齿算法背后的基本思想是相同的：预处理纹理并创建数据结构这将帮助快速的计算一个在一个像素上面的一组纹素的影响的近似值。对于实时计算，这些算法具有使用固定数量的时间和资源来执行的特征。以这种方式，每个像素获取固定数量的样本，并将其组合起来以计算（可能很大）一定数量的纹理像素的效果。

***Mipmapping*** （预处理纹理，形成不同级别的纹理尺寸，其实很多地方都是这样的思路，进行分级预处理提升计算效率，空间换时间）

最流行的纹理抗锯齿方法称为mipmapping。现在已生产的所有图形加速器均以某种形式实现了该功能。“ Mip”代表multum in parvo，拉丁语则代表“小地方的许多东西，这是一个过程的好名字，在该过程中，原始纹理被反复过滤成较小的图像。

使用mipmapping最小化滤波时，原始的贴图被扩展为一组更小版本的贴图，在进行实际渲染之前。纹理（零级）被下采样到原始面积的四分之一，每个新的纹理像素值通常被计算为原始纹理中四个相邻纹理像素的平均值。新的一级纹理有时称为原始纹理的子纹理。递归执行缩小，直到纹理的一个或两个维度等于一个纹理像素。 此过程如图6.15所示。 整个图像集通常称为mipmap链（*mipmap chain*）。

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%206%20Texturing(%E7%BA%B9%E7%90%86)%20cb0c3597962c4c4d85f92e77335ec33c/Untitled%2011.png)

将金字塔底部的原始图像（lod0），取2*2区域的平均值，作为下一级的纹素值，以此形成mipmap。垂直轴是第三个纹理坐标d。在这个图中，d不是线性的，它是用来测量使用哪两个纹理级别用于插值。

对于在非线性空间中编码的纹理（例如大多数颜色纹理），在过滤时忽略伽玛校正将修改感知到的Mipmap级别的亮度。当您离对象越来越远并且使用了未经校正的Mipmap时，对象的整体外观可能会更暗，并且对比度和细节也会受到影响。 因此，重要的是将此类纹理从sRGB转换为线性空间（第5.6节），在该空间中执行所有mipmap过滤，然后将最终结果转换回sRGB颜色空间进行存储。大多数API支持sRGB纹理，因此将在线性空间中正确生成mipmap，并将结果存储在sRGB中。 访问sRGB纹理时，首先将它们的值转换为线性空间，以便正确执行放大和缩小。

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%206%20Texturing(%E7%BA%B9%E7%90%86)%20cb0c3597962c4c4d85f92e77335ec33c/Untitled%2012.png)

**上图左侧为一个正方形像素单元及其纹理视图，右侧为像素单元到纹理本身的投影。**

如前所述，某些纹理与最终着色颜色具有根本上的非线性关系。 尽管这通常会给过滤带来问题，但由于要过滤数百或数千个像素，因此mipmap生成对此问题特别敏感。 为了获得最佳结果，通常需要专门的mipmap生成方法。 此类方法在第9.13节中进行了详细说明。（纹理压缩？）

mipmapping的好处在于，可以对预组合的纹素组进行访问和内插，而不是尝试对各个影响像素的所有纹素进行求和。无论缩小多少，此过程都会花费固定的时间。但是，mipmapping有几个缺陷。一个主要的是模糊。 想象一下，一个像素单元在u方向上覆盖大量纹素，而在v方向上仅覆盖少数纹素。这种情况通常发生在观看者近乎边缘地沿着带纹理的表面看时。实际上，可能需要沿着纹理的一个轴进行缩小，而沿着另一个轴进行放大。访问mipmap的效果是检索纹理上的正方形区域；检索矩形区域是不可能的。为了避免混叠，我们选择最大的度量来衡量纹理上像素单元的近似覆盖率。这导致检索到的样本通常相对模糊。 在下图的mipmap图像中可以看到这种效果。 向远处移动的线条显示出过度模糊。

***Summed-Area Table***

避免过度模糊的另一种方法是summed-area table(SAT) 。要使用此方法，首先要创建一个数组，该数组的大小与纹理大小相同，但包含更多的颜色存储精度位。（例如，红色，绿色和蓝色分别为16位或更多）。在此数组的每个位置，必须计算并存储所有相应纹理的纹素的总和，该矩形由该位置和纹素（0，0）（原点）形成。在纹理化过程中，像素单元在纹理上的投影由矩形限制。然后访问求和面积表以确定该矩形的平均颜色，该颜色作为像素的纹理颜色传回。使用下图所示的矩形的纹理坐标计算平均值。

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%206%20Texturing(%E7%BA%B9%E7%90%86)%20cb0c3597962c4c4d85f92e77335ec33c/Untitled%2013.png)

*****Unconstrained Anisotropic Filtering（这里后续单独一篇分析一下）***

> 如果Px为纹理在x坐标方向上的缩放的比例因子。Py为纹理在y坐标方向上的缩放的比例因子。Pmax为Px和Py中的最大值。Pmin为Px和Py中的最小值。当Pmax/Pmin等于1时。也就是说Px等于Py，纹理的缩放是各同向的；可是如果Pmax/Pmin不等于1而是大于1，Px不等于Py，**也就是说纹理在x坐标方向和在y坐标方向缩放的比例不一样，纹理的缩放是各异向的，Pmax/Pmin代表了各异向的程度。**
> 

对于当前的图形硬件，进一步改善纹理过滤的最常用方法是重用现有的mipmap硬件。基本思想是对像素单元进行反投影，然后对纹理上的这个四边形进行几次采样，然后对样本进行合并。如上所述，每个mipmap样本都有一个位置和一个与其关联的正方形区域。该算法不使用单个mipmap样本来近似四边形的覆盖范围，而是使用几个正方形覆盖四边形。可以使用四边形的较短边来确定d（不同于mipmapping中通常使用较长边的地方）； 这会使每个Mipmap样本的平均面积变小（从而减少模糊）。四边形的较长边用于创建一条平行于较长边并穿过四边形中间的各向异性线。当各向异性的量在1：1和2：1之间时，沿着这条线采集两个样本（见图6.18）。 在较高的各向异性比率下，沿轴将获取更多的样本。

![Untitled](/assets/blog/Realtime%20Rendering%204th%20-%206%20Texturing(%E7%BA%B9%E7%90%86)%20cb0c3597962c4c4d85f92e77335ec33c/Untitled%2014.png)

### 6.2.6 纹理压缩

直接攻击（attacks）内存和带宽问题以及缓存问题的一种解决方案是固定速率纹理压缩（texture compression）。通过让GPU即时解码压缩的纹理，纹理可以需要更少的纹理内存，因此可以有效的增加缓存大小。至少同样重要的是，此类纹理的使用效率更高，因为它们在访问时消耗的内存带宽更少。一个相关但不同的用例是添加压缩以提供更大的纹理。 例如，在512 ^ 2分辨率下每纹理像素使用3个字节的非压缩纹理将占用768 kB。 使用纹理压缩时，压缩比为6：1，1024 ^ 2纹理将仅占用512 kB。