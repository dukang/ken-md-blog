---
title: '(翻译系列) - Realtime Rendering 4th - 3. The Graphics Processing Unit(GPU)'
excerpt: 'The display is the computer."——Jen-Hsun Huang。那个显示器就是电脑。GPU硬件仅仅在计算速度上面优于CPU，而且速度也是有限制的（Critical）。'
coverImage: '/assets/blog/rr4-3/6.png'
date: '2022-07-24'
type: '实时渲染4TH'
author:
  name: Ken Du
  picture: '/assets/blog/authors/ken.png'
ogImage:
  url: '/assets/blog/rr4-3/6.png'
---

"The display is the computer."——Jen-Hsun Huang。那个显示器就是电脑。

GPU硬件仅仅在计算速度上面优于CPU，而且速度也是有限制的（Critical）。

延迟是所有处理器面临的问题。存储数据需要花费时间。可以这么理解，离处理器越远，获取数据时间越长，延迟越久。等待获取数据意味着处理器当前挂起了，这样降低了运行效率。

CPU在处理延迟的方式是用了多级内部缓存和内存，让获取数据更加快速，同时CPU通过各种算法避免处理去被挂起(stalled)。

GPU用了另外一种方式，使用了大量的处理器（shader cores），经常超过数千个。这样GPU更好的进行并行计算和处理。GPU执行过程中，如果遇到挂起，可以使用的切换到其它片元的方式来降低延迟(swap & wrap)。另外GPU也用了另外一种更近一步的方式，从数据里面分离了逻辑指令(single instruction, multiple data)

GPU从可配置的固定功能管线演变到了支持高度可编程的管线。直到如今，各种可编程着色器依然是控制GPU的主要手段。为了提高效率，GPU管线的一部分仍然保持着可配置，但不是可编程的，但大趋势依然是朝着可编程和更具灵活性的方向在发展。

假设一个mesh被光栅化成2000个像素，也就是说下面的像素着色器要被调用2000次。假设我们使用一个世界上最烂的GPU，只有一个着色器处理单元。它将从第1个**片元**开始执行着色器程序，一直到第2000个。着色器处理器针对寄存器上的数值执行了一些算数运算，由于寄存器是本地的，访问速度很快，所以不会出现停顿。然后，着色器要去执行一个纹理采样的指令，通过表面位置信息获取到图片中的颜色并将其运用给mesh。由于纹理是一些完全独立的资源，并非像素着色器的本地内存，所以需要去访问纹理。然而由于一次内存访问需要数百数千个时钟周期，而这个阶段GPU处理器无事可做。这时着色器处理器也就会停顿下来，去等待所需要的纹理颜色。

为了优化这种糟糕的GPU，可以给每个片元一个小的存储空间用来当做本地寄存器。现在，我们决定不停下来去等待纹理采样，目前的着色器处理器使得我们可以切换并执行另外一个片元，比如2000个片元中的第2个。这个切换很快，而且不会影响第一个或者第二个片元的任何内容，只需要注意目前第一个片元执行到哪条指令了即可。然而开始执行第2个片元，与第1个片元类似，执行一些算数函数，直到再次遇到纹理采样，然后依然切换到下个片元，第3个片元，直到2000个片元都通过这种方式处理完了

(PS：我记得纹理会被采样过来放在缓存中，但是也不会采样很多吧，比如对应2000个片元那么多，所以是不是执行一部分，比如200个，就知道纹理被采样过来一部分了，然后就去继续进行第1个片元了？不然2000个结束后，发现第1个片元的纹理ok了，但是第2个片元的纹理没被拿过来就尴尬了。)

此时，着色处理器返回到第一个片元。这个时候着色器所需要的纹理颜色已经获取到了，着色器处理器可以继续执行第1个片元的操作，这样下去，直到又遇到一个已知的会导致停顿的执行指令的到来，或者整个程序执行结束。从单个片元的执行时间来说，比不切换的模式要慢一点，但是总体来说，所有片元的总执行时间将大大缩短。

在这个体系结构中，通过不停的切换到另一个片元，使得GPU保持忙碌，从而隐藏了延迟。GPU通过把逻辑和数据分离，进一步实现了这一设计。这个技术被称为SIMD，single instruction multiple data。这样的安排，使得可以在固定数量的着色程序中通过lock-step技术执行相同的命令。相比较针对每个program使用一个独立的逻辑、调度，SIMD的优势在于调用了相当少的硅/power去处理这个事情。将2000个片元用于现在的GPU架构中，针对每个片元所调用的片元着色器都被称为一个线程。而这里的线程和CPU线程不同。它包含了一位内存用于存放该shader的输入，以及材质球执行所需要的任何寄存器空间。使用相同shader program的线程被合并成了一个group，在NV被称为warps，在AMD被称为wavefronts。一个Warps/Wavefronts被安排通过8-64个GPU Shader cores执行，使用SIMD技术。每个线程都被映射到了一个SIMD通道中。

假如我们有2000个thread需要被执行，NV GPU中的一个warps包含32个线程。也就是说将产生2000/32=62.5个warps，也就是说会分配63个warps，其中有一个warp有一半是空的。warp的执行类似于一个单一GPU执行的例子。因为这些线程执行的是相同的指令，当遇到内存提取时，所有的线程都会同时遇到。然后这个提取的信号会告知warps中的所有线程都停止等待他们（不同的）结果。而warps不会停止，而是转移到另外一个包含32线程的warp，然后使用这32个core继续执行。由于交换的时候没有任何数据被涉及，所以这种交换速度和我们的单处理器系统一样快。每个线程都有自己的寄存器，每个warp都会记录它执行到了哪个指令了。交换到一个新的warp只是将运算核心指向到另外一组线程继续执行了，而没有额外的开销。warps不停的执行和交换，直到全部结束。参考图3.1。

![Untitled](/assets/blog/rr4-3/1.png)

如上图所示，是一个简单的着色器执行实例。一个三角形的所有片元，被称为线程，gather成warps。这里每个warps显示包含4个线程，其实实际上是包含32个线程。该shader program包含5条指令。GPU开始对第一个warps执行这些指令，直到遇到了“txr”指令触发stall，因为这个指令需要时间去获取数据。然后切换到第二个warp，并开始执行该shader program的前三条指令，直到再次遇到了stall。下面第三个warp被执行和stall，然后就会切换回第一个warp继续执行。如果这个时候“txr”指令所需要的数据还没回来，则真的stall直到数据准备ok。每个warp将依次完成。

在我们的简单示例中，纹理的内存获取延迟会导致warps的切换。而实际上，由于warps的切换成本很低，所以更短的延迟都有可能会触发warps的切换。还有一些其他技术可以用于优化（参考文献[945]），而warp的切换是所有GPU最主要的用于消除延迟带来影响的机制。这个过程的具体工作还涉及到几个因素。比如，如果线程很少，warps也很少，那么可能就无法消除延迟带来的影响。

shader program的结构也是影响效率的重要特性之一。一个主要因素是每个线程的寄存器使用量。在我们的示例中，我们假设2000个线程可以同时驻留在GPU上。而每个线程相关联的着色器所需要的寄存器越多，可驻留在GPU中的线程就越少，warps也就越少。warps越少，也就意味着无法通过warps切换缓解延迟。入住的warps呗称为“in flight”，这个数据被称为入住率。高入住率也就代表着有足够多用于处理的warps，导致处理器空闲的可能性也就越小。而低入住率通常会导致性能不佳。内存获取的频率也会影响到底有多少延迟需要被消除。Lauritzen（参考文献[993]）描述了shader使用的共享内存以及寄存器的数量时如何影响入住率。Wronski（参考文献[1911、1914]）针对shader program中执行的操作类型对应的理想入住率。

另外一个影响整体效率的因素是由于if语句和循环引起的动态分支。假如在着色程序中有“if”语句，如果所有线程评估后都走了相同线程，那么warps就可以继续，而不用考虑另外一个分支。然而，如果一些线程，即使只有一个，走了另外一个分支，这样的话该warp久需要执行全部分支，丢弃每个特定线程不需要的结果（参考文献[530、945]）。这个问题被称为线程发散，其中一些线程可能需要执行循环迭代活着执行“if”路径，而warps中的其他一些线程不需要，从而使它们在此期间处于空闲状态。

所有的GPU都已经实现了这套体系架构，严格限制的系统，带来了每瓦的巨大的计算能力。了解这套系统可以帮助你更有效的使用它所提供的能力。在接下来的章节中，将会介绍GPU如何实现这些管线、可编程着色程序如何操作，以及每个GPU阶段的演进和功能。

![Untitled](/assets/blog/rr4-3/2.png)

上图中，不同颜色的阶段表示了该阶段不同属性。其中：

- 绿色的阶段都是完全可编程的。
- 黄色的阶段可配置，但不可编程。
- 蓝色的阶段完全固定。

### 可编程的shader阶段：

一次draw call 会调用图形API绘制一组多边形，其中会让渲染流水线编译和运行shader。每个shader可编程阶段都会有2种输入：uniform inputs(在一个drawcall内是静态的，但是会在不同的draw间进行变化)，varying inputs (光栅化后的值)

每个Shader Virtual Machine都是一样的架构，其中Constant registers是用来保存uniforms，register的数量用的相对比较多是因为需要存储texture以及其它参数是用来整个draw阶段都要用到，而varying input & output 对于每个顶点来说需要被分散保存，天然就会有限制（这里我认为是因为每个顶点作为shader 当前流程的计算 是一个一个传入的，然而uniform可能需要一直重复使用）

暂存空间(scratch space)用来保存这些register的index，用integer保存。

![Untitled](/assets/blog/rr4-3/3.png)

一段shader与GPU的发展史，可以详细阅读第三章

这里摘抄一部分关于Mobile:

> OpenGL ES 3.0 was released in 2012, pro- viding functionality such as multiple render targets, texture compression, transform feedback, instancing, and a much wider range of texture formats and modes, as well as shader language improvements. OpenGL ES 3.1 adds compute shaders, and 3.2 adds geometry and tessellation shaders, among other features. Chapter 23 discusses mobile device architectures in more detail.
> 

> An offshoot of OpenGL ES is the browser-based API WebGL, called through JavaScript. Released in 2011, the first version of this API is usable on most mo- bile devices, as it is equivalent to OpenGL ES 2.0 in functionality. As with OpenGL, extensions give access to more advanced GPU features. WebGL 2 assumes OpenGL ES 3.0 support.
> 

### 顶点着色（Vertex Shader）：

转换顶点的着色器，通常最小输出就是每个图元（三角形）的顶点坐标，然后创建生成后进行光栅化，最后单个的像素片元被送去像素着色器进行下一步操作。

### The Tessellation Stage:

这个阶段是可选的，可以渲染曲面（理解为单个三角形的曲面）

优势：

1. 相对于vertex自身提供，tessellation更加简洁，存储可以在CPU和GPU之间运行；
2. 表面计算可以函数化，更准确描述（可以用于LOD）

Tessellation stage通常由3个元素组成: hull shader, tessellator, domain shader.

![Untitled](/assets/blog/rr4-3/4.png)

### The Geometry Shader

这个阶段可以改变图元成为其他的图元（有时候Tessellation阶段做不了）。

### Stream Output

当顶点数据经过vertext shader处理后（可选被Tessellation阶段和Geometry阶段处理后），通常被输送到片元着色器中，中间的数据结果通常是不可访问的。

流输出是输出到一个流里面（i.e. 一个有序的数组，为了被送去光栅化阶段），可以让这部分数据重复使用（通常像水纹，骨骼等）

### The Pixel shader

Vertex, tessellation and geometry操作后，图元会经过裁剪后进入到光栅化。这个阶段是相对固定的，不可编程但是可以配置相应数据。通俗的说就是找出被图元（三角形）覆盖的像素点，被覆盖的像素点称为片元（fragment）。

三角形的顶点，包含Z-value(深度信息会保存进Z-buffer），会被插值计算。计算后，这些值会传入pixel shader，也在openGL里面称为fragment Shader。

使用什么类型的插值法是由pixel shader program决定的。一般用perspective-correct interpolation(透视矫正插值)

在pixel shader中修改颜色 depth 透明度的值，然后输出到merging stage。除了颜色和zbuffer, MRT可以输出和保存更多值。一般renderTarget 有4个或者8个。

在计算过程中一般当前像素颜色不能访问周边像素颜色的值，但是也有例外，在计算梯度和微分的时候（这块没有读懂，后续再来看）

![Untitled](/assets/blog/rr4-3/5.png)

### The Merging Stage

在这个阶段做深度剔除，模版剔除，以及blending。（是固定的阶段，可配置不可编程）

### The Compute Shader

在DirectX 11中，compute shader是一种shader没有被location锁住的shader在GPU中进行计算。计算一般发生在跟普通shader同样的地方，可以访问texture,有input 和 output。 在compute shader中wraps and threads更加明显。可以更加方便的访问线程，有线程的id和group。

compute shader的 一个很大的优势是能够访问GPU生成的数据。这样数据一直存放在GPU可以很大提升效率和性能。
![Untitled](/assets/blog/rr4-3/6.png)
