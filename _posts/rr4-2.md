---
title: '(翻译系列) - Realtime Rendering 4th - 2. The Graphics Rendering Pipeline(图形渲染流水线)'
excerpt: '流水线在工业各种场景里面使用的很多，用来描述产品生产的流程和顺序。流水线可以并行执行的，每一个级别都依赖于上一个层级的输出作为本层级的输入。理想状态下，一个“非流水化系统”，分割成n个流水线并行，理论上可以提升n倍的速度。'
coverImage: '/assets/blog/hello-world/cover.png'
date: '2022-07-24'
type: '实时渲染4TH'
author:
  name: Ken Du
  picture: '/assets/blog/authors/ken.png'
ogImage:
  url: '/assets/blog/hello-world/cover.png'
---

流水线在工业各种场景里面使用的很多，用来描述产品生产的流程和顺序。流水线可以并行执行的，每一个级别都依赖于上一个层级的输出作为本层级的输入。理想状态下，一个“非流水化系统”，分割成n个流水线并行，理论上可以提升n倍的速度。

再实时图形渲染中，渲染流水线通常被划分为4个主要阶段：

Application → Geometry Processing → Rasterization → Pixel Processing

渲染速率一般用FPS（Frames Per Second）来记录，一般渲染状态用一帧的渲染时间来表示（通常为ms）。总体来说，Application阶段发生在CPU，包括碰撞检测，物理模拟，动画等，这个阶段主要是根据不同的Task执行后，准备用来上传GPU的数据。Geometry阶段发生在GPU，这个阶段处理位移变化，投影等计算。这个阶段计算了怎么draw, draw在哪，draw什么。Rasterization阶段一般输入3个顶点，然后形成三角形，然后找到这个三角形内的所有像素点传递给下一个阶段。Pixel Processing会在输入的每个像素执行一个Program然后决定这个像素的颜色，这个阶段还会执行深度检测和混合等操作。

### Application 阶段

这个阶段发生在CPU，开发者可以整体的决定执行的方式和修改内容，以提高效率。这个阶段的优化也会影响接下来的阶段的性能（包括减面等）。

一些Application阶段可以发生在GPU，用一个叫Compute shader的方式。这里可以使用GPU并行能力（有时候用CS也会有一些其它特殊的需求）。

碰撞检测，裁剪，键盘输入等计算过程，一般都会发生在这个阶段。

### Geometry 阶段

Geometry阶段通常发生下GPU，对大多数的“每个三角形”，“每个顶点”进行计算和处理。这个阶段分为4个功能阶段：vertex shading, projection, clipping, and screen mapping；

这个阶段的一些Optionals:

1. Tessellation: 根据相机和物体的距离生产更密集或者更稀疏的三角面片；
2. Geometry Shader: 比较主要是在粒子的生成（火花四溅之类的效果）
3. Stream Output: 用GPU作为geometry的生产引擎，生成array为后续的pass提供输入

### Rasterization 阶段

对输入的已经变化后和投影后的顶点，以及他其它相关的数据（从Geometry 阶段的输出），找到这些数据中的所有像素点。其中包含两个步骤：Traiangle setup & triangle traversal。光栅化阶段把二维的顶点转变为屏幕的像素点。

**三角形设定 Triangle Setup**

三角形设定阶段主要用来计算三角形表面的差异和三角形表面的其他相关数据。该数据主要用于扫描转换（scan conversion），以及由几何阶段处理的各种着色数据的插值操作所用。 该过程在专门为其设计的硬件上执行。

**三角形遍历 Triangle Traversal**

在三角形遍历阶段将进行逐像素检查操作，检查该像素处的像素中心是否由三角形覆盖，而对于有三角形部分覆盖的像素，将在其重合部分生成片段（fragment）。

找到哪些采样点或像素在三角形中的过程通常叫三角形遍历（Triangle Traversal）或扫描转换（scan conversion）。每个三角形片段的属性均由三个三角形顶点的数据插值而生成（在第五章会有讲解）。这些属性包括片段的深度，以及来自几何阶段的着色数据。

【总结】找到哪些采样点或像素在三角形中的过程通常叫三角形遍历（Triangle Traversal）或扫描转换（scan conversion）。

### Pixel 阶段

分为Pixel shading 和 merging(ROP, Raster Operation pipeline, 通常是通过Z-buffer来填充合适的像素), 逐像素和逐样本的计算几何题内部的像素点。

### Pixel shading：

实时渲染管线（流水线），不是唯一的渲染管线，还有离线渲染管线，微几何渲染管线（近期被光线追踪和路径追踪所替代）。

像素着色阶段是在可编程GPU内执行的，在这一阶段有大量的技术可以使用，其中最常见，最重要的技术之一就是纹理贴图（Texturing）。简单来说，纹理贴图就是将指定图片“贴”到指定物体上的过程。而指定的图片可以是一维，二维，或者三维的，其中，自然是二维图片最为常见。如下图所示：

![Untitled](/assets/blog/hello-world/1.png)

原书图2.9 左上角为一没有纹理贴图的飞龙模型。左下角为一贴上图像纹理的飞龙。右图为所用的纹理贴图。

### **融合 Merging**

每个像素的信息都储存在颜色缓冲器中，而颜色缓冲器是一个颜色的矩阵列（每种颜色包含红、绿、蓝三个分量）。融合阶段的主要任务是合成当前储存于缓冲器中的由之前的像素着色阶段产生的片段颜色。不像其它着色阶段，通常运行该阶段的GPU子单元**并非完全可编程的**，但其高度可配置，可支持多种特效。（我理解为Blending ）

此外，这个阶段还负责可见性问题的处理。这意味着当绘制完整场景的时候，颜色缓冲器中应该还包含从相机视点处可以观察到的场景图元。对于大多数图形硬件来说，这个过程是通过Z缓冲（也称深度缓冲器）算法来实现的。Z缓冲算法非常简单，具有O(n)复杂度（n是需要绘制的像素数量），只要对每个图元计算出相应的像素z值，就可以使用这种方法

而当图元通过光栅化阶段之后，从相机视点处看到的东西就可以在荧幕上显示出来。为了避免观察者体验到对图元进行处理并发送到屏幕的过程，图形系统一般使用了双缓冲（double buffering）机制，这意味着屏幕绘制是在一个后置缓冲器（backbuffer）中以离屏的方式进行的。一旦屏幕已在后置缓冲器中绘制，后置缓冲器中的内容就不断与已经在屏幕上显示过的前置缓冲器中的内容进行交换。注意，只有当不影响显示的时候，才进行交换。

【总结】融合阶段的主要任务是计算之前阶段所生成片元颜色。此外，融合阶段还负责可见性问题（Z缓冲相关）的处理。