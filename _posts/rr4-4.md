---
title: '(翻译系列) - Realtime Rendering 4th - 4. Transforms'
excerpt: '转换（transform）是一种对某些实体（点，向量，颜色）施加的操作，并用某些方式对他们进行转化。对于计算机图形学工作者来说，掌握变换是极其重要的。有了他们，你可以定位，重塑，物体动画，光照，相机。你也可以保证所有的计算都在同一坐标系中进行，并以不同的方式将物体投射到平面上。这些仅是变换可以执行的部分操作，但足以证明变换在实时图形或任何形式的计算机图形中的重要性。'
coverImage: '/assets/blog/rr4-4/cover.png'
date: '2022-07-24'
type: '实时渲染4TH'
author:
  name: Ken Du
  picture: '/assets/blog/authors/ken.png'
ogImage:
  url: '/assets/blog/rr4-4/cover.png'
---

转换（transform）是一种对某些实体（点，向量，颜色）施加的操作，并用某些方式对他们进行转化。对于计算机图形学工作者来说，掌握变换是极其重要的。有了他们，你可以定位，重塑，物体动画，光照，相机。你也可以保证所有的计算都在同一坐标系中进行，并以不同的方式将物体投射到平面上。这些仅是变换可以执行的部分操作，但足以证明变换在实时图形或任何形式的计算机图形中的重要性。

变换是操作集合体的基础工具。大部分图形应用有相关接口设置专门的矩阵，也有库进行矩阵的计算。但是我们还是有必要知道矩阵之间的交互以及这些运算背后的逻辑和原理。

“Therefore, we have to keep in mind that both clipping (frustum culling) and NDC transformations are integrated into GL_PROJECTION matrix.”

我感觉这里是说可以把计算放入到projection matrix但是实际上的齐次除法发生在GPU阶段

[http://www.songho.ca/opengl/gl_projectionmatrix.html](http://www.songho.ca/opengl/gl_projectionmatrix.html)

这篇文章有说投影矩阵里面包含了视角空间转换为裁剪空间，然后转化为NDC空间。所以一般VS输出既是裁剪后的NDC空间的坐标。

但是有文章又说VS输出的是裁剪空间坐标，这里我比较赞同外文的文章，根据算法来看投影矩阵已经除以了齐次坐标了。

## 4.1 Basic Transforms 基础变换

这里线性代数这篇里面有写就不详细总结了

[https://www.notion.so/part1-d4aefbc3925a41e9b0e203d14b2f44da](https://www.notion.so/part1-d4aefbc3925a41e9b0e203d14b2f44da)

[https://zhuanlan.zhihu.com/p/106842678](https://zhuanlan.zhihu.com/p/106842678)

4.1.1 平移矩阵

平移矩阵是指从一个地址变化到另外一个的矩阵。平移向量t = (tx, ty, tz)，用矩阵表达如下：

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8a425dcb-6f79-43dd-91b4-b37be8049ccf/Untitled.png)

然后矩阵乘以点p(px, py, pz,1), 得到一个新点p`(px + tx, py + ty, pz + tz, 1)，这样就形成平移。需要注意的是向量 v = (vx, vy, vz,0) 乘转换矩阵T 不会受到影响，因为一个方向是没办法进行平移的。相反，点和向量都受仿射变换的其余部分的影响。平移矩阵的逆为T（t）=T（-t），也就是说，向量t取反。

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9e15fffb-fa7c-4951-9a52-dc6f9c437f7d/Untitled.png)

在这里我们应该提一点，有时在计算机图形学中看到的另一种有效的符号表示方案是使用矩阵，其底行具有平移矢量。比如DX就是使用这种形式。在这个方案中，矩阵的顺序将被颠倒，即应用程序的读取顺序变为从左到右。这个表示法中的向量和矩阵被认为是行的主要形式（row-major），因为向量是行的。在这本书中，我们使用了列为主要形式（column-major）。不管使用哪一种形式，其实只是一个符号不同的区别罢了。当矩阵存储在内存里面的时候，16个值中的最后四个是3个平移值加一个1。

4.1.2 旋转

旋转变换通过一个给定轴和角度旋转了一个向量（点或者方向）。跟平移矩阵一样这属于刚体变换。即，它保留了变换后的点之间的距离，并保留了惯用性(handedness)（即，它不会导致左右两侧互换）。这两种转换在计算机图形学里对于物体的定位和定向是很有用的。一个定向矩阵（orientation matrix）是一个关联摄像机视角或者物体的旋转矩阵，这个矩阵定义了在空间它自己的方向。即它向上，向前的方向。

在二维空间里面，旋转矩阵可以被简单推导出来。假设我们有一个向量v(vx, vy)，参数化以后我们得到v = (rcosθ, rsinθ)。如果我们旋转这个向量φ角度（顺时针），我们将会得到u = (r cos(θ + φ), r sin(θ + φ))

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7a5f5227-762d-40ab-9548-1280fffa1161/Untitled.png)

在这里，我们使用角和关系式展开了 cos(*θ* + *φ*) 和 sin(*θ* + *φ*)。在三维空间里，常用的旋转矩阵有Rx（φ）、Ry（φ）和Rz（φ），他们是分别绕着x轴，y轴，z轴各自旋转 *φ* 弧度。这里给出了三个公式。

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4140cc93-23d8-462b-87de-29a8991d1b97/Untitled.png)

如果把底部的一行和最右面的一列从 4 X 4的矩阵里面删除，那么就得到了一个3X3的矩阵。对与每一个3X3的旋转矩阵，**R**，在绕任意轴旋转φ弧度时，轨迹（即矩阵中对角线元素的和）是常数，与轴无关，并计算为

tr(R) = 1 + 2 cos φ.

关于旋转矩阵的影响可以看下图（下图还有一部分是缩放矩阵的作用）。旋转矩阵表现了这样的一个特色，Ri(φ)，实际上当它绕着i轴旋转 φ 的时候，在 i 轴上的所有点不会发生变化。也请记住，R也用来表示绕着任何轴旋转的旋转矩阵。绕任意轴旋转的操作可以使用一系列上面给出的轴旋转矩阵来达到。

所有的旋转矩阵都有行列式为1，并且是正交的。这个对于任何数量的转换级联也成立。这里也有另外一种求逆的方式（下图）：即绕着相同的轴进行相反角度的旋转。R−1(φ) = Ri(−φ)

例子：

假设我们想让一个物体绕Z轴旋转φ弧度，旋转中心是某一点P。那么应该怎么旋转呢？下图描述了这个情况。由于绕点旋转的特征在于该点本身不受旋转的影响，那么旋转开始的时候通过平移矩阵T（-p）来让P点与原点重合。之后进行实际的旋转操作Rz(*φ*)。最后在使用平移矩阵T（p）来让物体回到初始的位置。那么得到的变换 X 就是，注意矩阵的顺序。

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/61889aca-bbdd-4b11-9757-180803ef0ee8/Untitled.png)

4.1.3 缩放（非线形变换）

一个缩放矩阵，**S**(**s**) = **S**(sx, sy, sz)，分别沿X方向，Y方向，Z方向有一个缩放因子sx, sy, 和sz。 这意味着缩放矩阵可以对一个进行扩大或者缩小。si，i∈{x，y，z}越大，在该方向上缩放的实体越大。把si某方向的分量设置成1，那么就可以避免在这个方向上面的缩放。

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2eb53a3c-c1fa-454e-8e27-47e7dcfb602f/Untitled.png)

使用齐次坐标，创建统一缩放矩阵的另一种有效方法是通过操作位置（3，3）处的矩阵元素，即右下角的元素。这个值会影响齐次坐标W分量并且会对每一个通过该矩阵进行转化的点（不是方向向量）进行缩放。例如，如果想进行5倍的放大，那么可以把缩放矩阵 (0*,* 0), (1*,* 1),和 (2*,* 2)点的值设置为5，或者把(3*,* 3) 点的值变为 1/5。两种不同的矩阵如下图。

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7d174a7b-9c9f-4217-a07c-a5f6cd391a7c/Untitled.png)

与使用S矩阵进行均匀缩放不同的是，右边的矩阵必须时刻遵循均匀缩放。另外这种方法可能是低效的，因为他在均匀缩放的过程中涉及到除法。如果右下角（3，3）的元素为1，那么除法就不是必须的。当然，如果系统经常做一些不是 除 1 的除法，那么没有额外的开销。

当一个负值在一个或三个组件的矩阵S上时，为反射矩阵，也称为镜像矩阵。如果只有两个缩放因子是-1，那么我们将旋转 π弧度。这里需要提醒的是一个关联反射矩阵的旋转矩阵也是反射矩阵。所以下面的的也是反射矩阵（等式右侧）。

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1bf1f86b-d81e-4c5a-b80b-d9fbc88e819c/Untitled.png)

按一定方向进行缩放。缩放矩阵 S 仅会在x，y，z方向进行缩放。如果需要在其他方向进行缩放，则需要复合变换。假设缩放沿着三个正交的，正方向向右的三个向量 fx，fy，fz。首先构建矩阵F，如下图：

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0ac5ceda-012b-4e16-beb8-2eac1c2d48da/Untitled.png)

其思想是让给出的三个坐标轴与标准坐标轴重叠，然后使用标准矩阵缩放，然后在转换回来。第一步是与F的转置（即逆）相乘。然后进行实际的缩放，接着在转换回来。转换矩阵X如下：

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/649bb4b3-66f4-4258-aafe-31fee7cedce0/Untitled.png)

4.1.4 Shearing 推移（切变）

其中一种变换是shearing变换矩阵。shear变换直观理解就是把物体一边固定，然后拉另外一边

这个变换可能会用于游戏创造一种奇幻的特效，或者改变模型的外观。这里有6种基础的裁剪矩阵。他们被定义为**H**xy(s), **H**xz(s), **H**yx(s), **H**yz(s), **H**zx(s)和 **H**zy(s)。第一个下标用于表示哪一个坐标被错切矩阵改变，第二个下标表示完成错切的坐标。

可以从方程4.15中观察到两个下标可以用于确定参数s的位置: x对应第一行，即索引为0的行，z对应第3列，即索引为2列。所以，s应放在矩阵(0, 2)处。用这个错切矩阵乘以一个点 P产生的结果为:

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fd638299-79a0-4dd5-a8ad-1aca4fd7b413/Untitled.png)

 下面图4.3清晰地说明了这个错切矩阵施加在一个单位正方形上的效果。在图4.3中y, z轴的值不受影响，而x轴的值为旧的x轴加上
乘以z的值，结果正方形变成了倾斜了，成了一个平行四边形。可以注意到变换后面积保持不变(阴影部分或者根据平行四边形面积计算公式就知道了)。

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cb9b16c4-d1d5-4601-a1a5-eb16bef9a1b6/Untitled.png)

将一个点P与这个矩阵相乘，产生的结果是返回一个点 (px+**s,** pz ,py , pz)T 。下图展示了一个单位体乘Hxz（s）的效果。Hij（s）的转置矩阵，可以通过相反方向进行裁剪来生成。所以：

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/397b5e09-de17-4854-b009-a35e38f9129a/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/85ded63f-5364-4c33-8d5c-a330ba334324/Untitled.png)

**4.1.5 变换连接（Concatenation of Transforms）**

由于矩阵乘法不遵守交换律，这些变换矩阵相乘的顺序很重要。因此变换连接(concatenation of transforms)是顺序依赖的(order-dependent)。

举个例子，考虑两个矩阵 S和R 。其中， S(2, 0.5, 1) 把x坐标放大为原来的两倍，y坐标缩小为原来的一半，z坐标不变。而 Rz(PI / 6)绕z轴逆时针旋转  PI / 6弧度。这两个矩阵可以按两种方式相乘，而结果却大不相同，如下面图4.4所示。

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5e434951-38c6-4039-96f0-38da2d4566ab/Untitled.png)

显而易见，把一个矩阵序列通过矩阵乘法转换成单个矩阵的好处是提升计算效率。一般的变换顺序是先缩放，再旋转，最后平移，合成一个矩阵就是:

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3b4a6144-08a9-4923-8eb5-37e8a0037353/Untitled.png)

实际计算时，是这样的(按括号顺序):

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/887f6c1b-6514-459a-bb6c-bf3d1b43d155/Untitled.png)

别外需要注意的是，矩阵乘法虽然不遵守交换律，但遵守结合律(associative)。所以可以对连接的变换矩阵进行分组计算:

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/203eefc0-f045-4b8f-b891-d4832473076d/Untitled.png)

其中TR是刚体变换部分，可能你只想计算这部分一次。

**4.1.6 刚体变换**

什么是刚体变换呢？举个例子，你从课桌上拿了一支钢笔，然后放进书包里了，则这只钢笔只是朝向和位置变了，而钢笔的形状没有发生变化。这样**只有平移和旋转组成的变换称为刚体变换(rigid-body transform)**。刚体变化具有保持长度(lengths)、角度(angles)和handedness不变性。

任何的刚体矩阵，X，可以被写成一系列的平移矩阵T和旋转矩阵R。X一般可以被表示为：

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/857e9327-26df-4616-a293-1467a7f0a8df/Untitled.png)

 X的逆矩阵计算过程为：

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7b5bf81b-0a91-4909-b3f2-e2ae54bb8322/Untitled.png)

[理解旋转矩阵的逆等于旋转矩阵的转置](https://zhuanlan.zhihu.com/p/359963717)

（通过上面的文章理解，旋转矩阵的逆矩阵等于旋转矩阵的转置）

因此计算逆矩阵，可以把左上角 3 X 3的矩阵R 进行转置操作，然后把平移矩阵T 的值改变一下符号。新获得两个矩阵用相反的顺序进行相乘然后得到X的逆矩阵。计算X逆矩阵的另外一个方法是考虑 R 和 X 的符号：

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e73dffa0-a751-4937-9615-3d832af9f2fd/Untitled.png)

其中 r,0 的意思是 旋转矩阵的第一列（逗号表示从0到2的任何值，而第二个下标是0表示第一列），而 rT0，则表示列矩阵的第一行。提醒一下 **0** 是一个 3 X 1 填满0的列向量。经过一些计算得到的逆矩阵为：

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e75a0eeb-d427-48a5-9d4d-d6f49186acd0/Untitled.png)

例子：调整摄像机的方向。图形中一个常见的任务就是调整摄像机让其可以看到某一位置。这里我们将介绍 gluLookAt() 函数（来自OpenGL Utility Library，简称GLU）的作用。假设摄像机的位置在 c 点，我们希望摄像机可以看到一个目标 l，摄像机给定一个UP方向 u'，如下图所示。

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/098b58be-a85f-4e4d-b6a1-e3c3dcc0c7c1/Untitled.png)

我们想计算三个基向量 {**r**, **u**, **v**}。我们首先计算视角向量 v = (**c - l**) / ||**c - l** ||，即从目标到摄像机位置的归一化向量。看向右边的向量也可以被计算 **r = (v X u') / || (v X u') ||**。因为 u' 通常不能保证指向精准的正上方，最终向上的向量是另外通过叉乘产生的向量。**u = v X r，**u 可以被保证归一化，因为 **v**和 **r** 都已经被归一化并且互相垂直。我们将要构建的摄像机的转换矩阵 M。其思想首先是把所有的东西进行转化，让摄像机处于原点位置 （0，0，0），然后改变基向量使 **r** 与（1，0，0）对齐，**u**与（0，1，0）对齐，**v**与（0，0，1）对齐。具体流程可看下图。

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/da77c280-b59e-4b41-b43c-a69950d99c17/Untitled.png)

需要注意的是，当平移矩阵与 改变基向量的矩阵 连接到一起的时候，平移矩阵 **-t**在右边，所以它应该先被应用。下面有一种可以记住 **r u** 和 **v** 放在哪里的方法。我们想让 **r**变成 (1,0,0)，所以当变化基向量的矩阵与 （1，0，0）相乘时，我们可以看到矩阵的第一行的元素必须是 **r**，因为 **r** *·* **r** = 1。此外，第二行和第三行必须由与r垂直的向量组成，即 **r · x**=0。当对**u**和**v**也应用相同的思想时，我们得出上述基矩阵的变化。

## 4.2 欧拉角The Euler Transform

欧拉角是一种比较适合直觉的方式来组建矩阵来控制自身的方向（包括摄像机或者其他实体的方向）。欧拉变换一般是三个矩阵的乘法：

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c2c93ce1-629b-4995-8b07-c02c2e24a164/Untitled.png)

这些矩阵的顺序可以有24个不同的选择；上述等式是较为普遍的情况。因为E是一系列的旋转组成，所以E也是正交的。所以就会有E−1 = ET = (RzRxRy)T = RTy RTx RTz，当然直接使用 **E** 的转置来求逆矩阵更直接。

欧拉角 h，p 和 r 表示head，pitch 和 roll 应以其顺序绕其各自的轴旋转多少。有事这些角度也被叫做 “rolls”，例如： head 是 “y-roll”， pitch 是 “x-roll”。此外，head 有时被称为 “yaw”，在飞行模拟里面。

P.S. ***这里有些有意思的点： 大多数制造工艺（包括3D打印）都认为z方向在世界空间中向上。航空和海上车辆认为-z向上。 建筑和GIS通常使用z向上，因为建筑平面图或地图是二维的x和y。与媒体相关的建模系统通常将y方向视为世界坐标上的向上方向，以匹配我们始终在计算机图形学中描述相机的屏幕向上方向的方式。这两个世界向上矢量选择之间的差异仅相差90°旋转（并且可能是反射），但不知道假定哪个会导致问题。 在本卷中，除非另有说明，否则我们使用y向上的世界方向。***

欧拉角对于小角度的改变或者是观察者方向很有用，但是欧拉角也有很多严重的限制。很难同时使用两组欧拉角进行组合。例如，在一组和另一组之间进行插值并不是对每个角度进行插值的简单问题。 实际上，两组不同的欧拉角可以给出相同的方向，因此任何插值都不应旋转对象。这也是为什么会使用其他替代的定位方式的原理，例如随后讨论的四元数。使用欧拉角，还将会遇到万向锁问题，稍后也会进行讨论。

关于如何从欧拉矩阵里面提取不同的旋转角度就需要直接阅读书本72-73页的内容。

## 4.3 四元数

尽管四元数是 Sir William Rowan Hamilton 于1843年发明的，是对复数的扩展，但是它直到1985年才被 Shoemake 引入到计算机图形领域。四元数用来表示旋转和方向。四元数在几个方面都优于欧拉角和矩阵。任何三维方向都可以表示为围绕特定轴的单个旋转。在此轴和角度表示的情况下，直接转换为四元数或从四元数转换都非常简单，而在任一方向上进行欧拉角转换都具有挑战性。四元数可用于方向的稳定和恒定插值，而欧拉角无法很好地完成这些操作

复数有实数和虚部。每一个实数由两个实数表示，第二个实数要被乘上\sqrt{-1}。同样的，四元数也有四部分。前三个值与旋转轴密切相关，旋转角度会影响所有四个部分。每个四元数用四个实数表示，每个实数与不同的部分相关联。由于四元数具有四个分量，因此我们选择将它们表示为向量，但是分了区分他们，我们在它们上加了一个帽子：**q^**。我们从四元数的一些数学背景开始，然后将其用于构建各种有用的变换。

### **4.3.1 Mathematical Background**

我们从定义一个四元数开始。

一个四元数可以通过以下方式定义，这些都等价

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/74710228-d307-4f01-8d74-f11b060e1cb5/Untitled.png)

变量 **qw** 是四元数的实部，虚部是**qv**， i，j，k 被叫做虚部的单位。

## 4.4 Vertex Blending （也叫linear blend skinning 线性混合蒙皮）

想象一下，这里有一个数字角色的手臂使用前臂和上臂两部分进行动画处理，如下图左边所示。模型的动画可以使用刚体转化进行。但是，这两个部分之间的关节将不会像真正的手肘。这是因为使用了两个单独的对象，因此，关节由来自这两个单独的对象的重叠部分组成。显然，最好只使用一个对象。 但是，静态模型的部分不能让肘部具有柔性。

顶点混合（Vertex blending）是解决这个问题的常用方法之一。这种技术还有其他的几种名字，例如线性混合蒙皮（linear-blend skinning），包络（enveloping）或骨架子空间变形（skeleton-subspace deformation）。

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/85834f93-eae0-4d0c-af61-eb993ccd2e28/Untitled.png)

通过进一步采取这一步骤，可以允许单个顶点由多个不同的矩阵变换，由此产生的位置加权并混合在一起。这是通过为动画对象设置骨骼骨架来完成的，其中每个骨骼的变换可能会通过用户定义的权重影响每个顶点。由于整个手臂可能是“弹性的”，即所有顶点都可能受到多个矩阵的影响，所以整个网格通常被称为皮肤（skin）（在骨头上）。具体例子可以看下图。许多商业建模系统都具有相同的骨架骨骼建模功能。尽管名称如此，骨骼并不一定必须是刚性的。 例如，Mohr和Gleicher提出了添加附加关节以实现诸如肌肉隆起等效果的想法。 James和Twigg讨论了使用可挤压和拉伸的骨骼来制作蒙皮动画。

## 4.7.2 透视投影

在实际渲染场景之前，场景中所有的对象都必须投影到某种平面或者某种简单体积上。之后，执行裁剪和渲染（详见2.3节）。

到目前为止，本章中的所有转换都没有处理第四分量，w分量。也就是说，点和向量在转换后保留了它们的类型。而且，4*4矩阵最下面的一行总是（0,0,0,1）。不过，透视投影矩阵不是这样的：最下面一行包含向量和点操作数，并且通常需要均匀化过程。也就是说，w通常不为1，所以需要除以W才能得到非齐次点。正交投影比较简单，也是常用的投影方法，在本节中首先讨论，它不影响w分量。

在本节中，假设观察者沿着相机的负Z轴观看，Y轴指向上方，X轴指向右侧。这是一个右手坐标系。有些文本和软件，例如DX，使用左手坐标系，观察者将沿着相机的正Z轴观看。这两个系统同样有效，最终将达到同样的效果。

一个比正投影更复杂的变换是透视投影，它是大多数计算机图形应用中常用到的。在经过透视投影后，平行的线通常不再平行。相反，它们可能会在极端情况下收敛到单个点。透视更接近现实中我们如何感知世界，即更远的物体更小。

首先，我们将给出一个透视投影矩阵的指导性推导，它投影到平面z=-d，d>0上。我们从世界空间出发，用于简化理解对世界空间到视角空间转换的过程。在这一推导之后，使用了更传统的矩阵。

假设摄像机（视点）位于原点，然后我们想把一个点P投影到一个平面z = -d上面，d>0，然后返回一个新的点 q = （qx,qy,-d）。下图展示了这个情况。